Mozilla tutorial
    https://developer.mozilla.org/es/docs/Web/JavaScript

Cosas interesantes que saber
    const numNeighbours = prompt('How many neighbour countries does your country have?')
        Aparece un recuadro con la pregunta y guarda la variable en numNeighbours
    Si queremos quedarnos con solo 2 decimales en una cuenta usamos toFixed(Decimales)
        let n = (1441/7900)*100     Resultado: 18.240506329113924
        n = n.tofixed(2)            Resultado: 18.24
        console.log(percentageOfWorld1(population).toFixed(4))
    Para mover una linea hacia abajo/arriba en VS usamos ALT y la flecha abajo/arriba
    CONST es solo invariable para primitives(Primitive values) pero si son objetos(Reference values) si que podemos cambiar su valor.
        Primitives vs objects (primitive vs reference types)



---------------------- FUNDAMENTOS JS PARTE 1 ----------------------

How to use modern JS today
    ES5
        fully supported in all browsers (down to IE9 from 2011)
        Ready to be used today
    ES6/ES2015 to ES2020
        ES6+: well supported in all modern browsers
        No support in older browsers
        Can use most features in production with transpiling and polyfilling(Babel)
        Compatibility table: https://kangax.github.io/compat-table/es6/
    ES2021
        ESNext: future versions of the language (new feature proporsals that reach stage 4)
        Can already use some features in production with transpiling and polyfilling
    En este curso aprenderemos ES6 pero hay algunas cosas que saber en ES5(por ejemplo en ES5 se usaba var y en ES6+ se usa let y const).
        Es necesario para saber como funciona JS mejor
        Muchos tutoriales estan en ES5
        Cuando trabajemos en codebases antiguas, deben estar escritas en ES5

7 Primitive Data Types. But JS automatic detect the type of data of the value stored in a variable.
    Number: floating point number.
    String: sequence of characters.
    Boolean: true or false.
    Undefined: value taken by a variable that is not yet defined.
    Null: also means 'empty value'
    Symbol(ES2015): value that is unique and cannot be changed.
    BigInt (ES2020): larger integers than the number type can hold
    Podemos descubrir el tipo de data usando typeof
        typeof true     Resultado: Boolean

let, const and var
    Let(ES6): Variable that changes in future.
        let age;
        let age = 30;
    Const(ES6): Variable that will not change in the future.
        const birthYear = 1990;
        NOT ALLOWED const birthYear;
    Var: old way to define variables. Same use like "let"

Operators
    + - * / = !=
    Exponential(**): 2 ** 3 -> 2*2*2
    Contracciones(+=): por ejemplo x = 15;
        x += 10; x = 25
        x *= 2; x = 50
        x++; x= 51
    Comparison
        < <= > >=

Strings
    Ejemplo:
        const name = "Jonas";
        const year = 2021;
        const birthYear = 1990;
    Podemos concatenar strings
        const presentation = "I'm " + name + " and I have " + (year - birthYear) + " years old";
    Pero tambien podemos concatenar strings asi
        const newpresentation = ´I'm ${name} and I have ${year - birthYear} years old´
        OJO que no son ni "dobles" ni 'simples', es la de debajo del `exponencial`

Type Conversion and Coercion
    Conversion
        manually convert from one type to another
            const inputYear = '1990';
            console.log(inputYear + 18);                    Resultado: 199018
            console.log(Number(inputYear), inputYear)       Resultado: 1990 "1990"
            console.log(Number(inputYear) + 18)             Resultado: 2008
            console.log(Number('Jonas'))                    Resultado: NaN
    Coercion
        JS automatically converts types behind the scenes for us
            console.log('I am ' + 30 + ' years old')        JS transform "23" into a String
            console.log('23' - '10' - 3)                    Resultado: 10
            console.log('23' + '10' + 3)                    Resultado: 23103
            console.log('23' * '2')                         Resultado: 46
            console.log('23' > '18')                        Resultado: true
            Funciona para todos los operadores el cambio de string a number menos para la suma "+"
            let n = '1' + 1;    // 11
            n = n - 1;          // 10
            '10' - '4' - '3' - 2 + '5'      //15

Boolean Operators
    AND : &&
    OR : ||
    NOT : !== 
        bool = true; 
        !bool = false;

Switch Statement
    Se usa como IF pero cuando hay muchos casos, y en vez de usar ELSE IF continuamente usamos el esquema Switch
    Switch(day){
        case "monday":  // day === "monday"
            console.log("On monday, plan course structure.")
            console.log("Go to coding")
            break         Sin el break, el codigo continua ejecutandose. Si lo quitamos este break se ejecutaria monday y tuesday
        case "tuesday":
            console.log("On tuesday, ...")
            break
        case "wednesday":
        case "thursday":            //Si ponemos esta estructura de dos case seguidos, para ambos se ejecuta el console.log
            console.log("On wednesday and thursday, ...)
            break
        default:
            console.log("Para cuando no se cumple ningun caso")
    }
    Cada dia se usa menos, pero en ocasiones es mejor usarlo

Statement and Expresions
    Expresions: producen values. No generan acciones.
    Statements: no producen values. Generan acciones.
        if (23<10){                             Todo el if es un Statement
            const str = "23 isn't bigger"       Esto tambien es un Statement, pero el "23 isn't bigger" es una Expresion. y str tambien es una expresion
        }
    Es importante saber la diferencia porque JS permite usar Statements y Expresions o no.
        Ejemplo:
            console.log(`i am ${2020 - 1990} years old.`)                               Permitido
            console.log(`i am ${if(2020 > 1990) {const edad = "30"}} years old.`)       No permitido
    
The Conditional/Ternary Operator
    Is the same than IF/ELSE but all in one line
        const age = 30
            // Condicion ? "what happen if TRUE" : "what happen if FALSE"
        age >= 18 ? console.log("I can drive.") : console.log("I can't drive.")
    La forma de usar el condicional realmente es:
        const drive = age >= 18 ? "can" : "can't"
        console.log(drive)
    Con IF/ELSE quedaria
        let drive
        if (age > 18){
            drive = "can"
        } else {
            drive = "can't"
        }
        console.log(drive)
    Pero como el Conditional es una expresion podemos aprovecharnos de ello
        console.log(`I ${const drive = age >= 18 ? "can" : "can't"} drive.`)
    


---------------------- FUNDAMENTOS JS PARTE 2 ----------------------

Strict mode
    It is a mode that will can enable in JS, it makes more secure write code
    To activate it, in the first line of the JS archive we write
        'use strict'
    It can be enabled and disabled for pieces of code
    Make it easier for us developers to avoid accidental errors. Help us introduce bus into our code.
        Stric mode forbids us to do certain things
        It will actually create visible errores for us in certain situations in wich without strict mode JS will simply fail silently.
    Example:
        let hasDriversLicense = false
        const passTest = true
        if (passTest) hasDriverLicense = true
        if (hasDriversLicense) console.log("I can't drive.")        Resultado: Nothing appears and no error is displayed
    Example 2:
        'use strict'
        let hasDriversLicense = false
        const passTest = true
        f (passTest) hasDriverLicense = true
        if (hasDriversLicense) console.log("I can't drive.")        Resultado: Appear an error in the console
    Strict mode also reserve some words
        let interface
        let private
        let if

Functions
    It is a piece of code that can be used over and over again in our code
    Creation function
        FUNCTION name (parameters) {}
        function loggger () {console.log("Hi")}
    Calling / running / invoking function
        NAME()
        logger()
    The functions have return of values
        function fruitProcessor(apples, oranges) {
            const juice = `Juice with ${apples} apples and ${oranges} oranges.`
            return juice
        }
        const applejuice = fruitProcessor(5, 4)     //We need to save the return in a variable or use directly, not calling the return.
        console.log(juice)                          Resultado: Error
        console.log(applejuice)                     Resultado: Juice with 5 apples and 4 oranges.
        console.log(fruitProcessor(9, 41))           Resultado: Juice with 9 apples and 41 oranges.

Function expresion and declaration
    Function declaration
        function calcAge1(birthYear){
            return 2020 - birthYear
        }
        const age1 = calcAge1(1990)
        console.log(age1)
    Function expresion
        const calcAge2 = function (birthYear){
                            return 2020 - birthYear
                         }
        const age2 = calcAge2(1990)
        console.log(age2)
    In declaration we can call first the variable and later the function, in expresion we can't do it
        const age2 = calcAge2(1990)
        const calcAge2 = function (birthYear){
                            return 2020 - birthYear
                         }
        Resultado: It don't works
        const age1 = calcAge1(1990)
        function calcAge1(birthYear){
            return 2020 - birthYear
        }
        Resultado: It works
    In practice, we can use both of them, it depends on the preference of the developer

Arrow functions
    Is a special form of function expression that is shorter and faster to write.
    Normal function:
        const calcAge2 = function (birthYear){
            return 2021 - birthYear
        }
    Arrow function:
        const calcAge3 = birthYear => 2021 - birthYear
        const age3 = calcAge3(1990)
        console.log(age3)
    If we need more complexity
        const yearsUntilRetirement = (birthYear, firstName) => {
            const age = 2021 - birthYear
            const retirement = 65 - age
            return `${firstName} retires in ${retirement} years`
        }
        console.log(yearsUntilRetirement(1990, "Jose Luis"))
    
Calling other Functions
    Example:
        let cutFruitPiece = fruit => fruit * 4
        function fruitProcessor (apples, oranges){
            const applePieces = cutFruitPiece(apples)       //applePieces = 2 * 4
            const orangePieces = cutFruitPiece(oranges)     //orangePieces = 3 * 4
            const juice = `Juice with ${applePieces} piece of apple and ${orangePieces} pieces of orange.`
            return juice
        }
        console.log(fruitProcessor(2,3))

Arrays
    Creation
        const friends = ["Jose Luis", "Pepito", "Pedro", "Horse Lluis"]
        const years = new Array (1990, 1991, 1992, 1993)
    Calling Arrays
        friends[0]
        years[3]
    Complexity
        const me = ["John", "Perez", 2021 - 1985, friends]      Array inside of a Array
    With functions
        const years = [1990, 1991, 1992, 1993]
        const calcAge = function (birthYear){
            return 2021 - birthYear
        }
        const ages = [calcAge(years[0]), calcAge(years[1]), calcAge[years(years.length])]
    Adding elements to the Array
        frients.push("Antonio")         Antonio is added to the end of the array
        friends.unshift("Pedrito")      Pedrito is added to the beginning of the array
    Removing elements to the Array
        friend.pop()                    The last element of the array will be removed
            const popped = years.pop()      Resultado(console.log): 1993
        friends.shift()                 The first element of the array will be removed
    Finding an element in the array
        friends.indexOF("Pepito")       Resultado(c.l): 1
        friends[friends.indexof("Pepito)] = "Pepe"

Objects
    structure
        const jonasArray = {
            //propierty : value
            firstName : "Jonas",
            lastName : "Perez",
            Age : 2021 - 1991,
            Job : "Teacher",
            Friend : ["Michael", "Peter", "Steven"]
        }
    Creating objects with functions
        const funcion = function (nombre, apellido, edad) {
            const objeto = {
                firstName: nombre,
                lastName: apellido,
                age: edad
            }
        return objeto
        }
        const persona = funcion("Antonio", "Gonzalez", 55)       Resultado: const objeto = {firstName: "Antonio", lastName: "Gonzalez", age: 55}
    DOT vs BRACKET notation
        DOT
            persona.name                         Resultado: Antonio
        BRACKET
            persona["name"]                      Resultado: Antonio
            Inside the brackets we can use any expresion.
                const nameKey = "Name"
                persona.["first" + nameKey]         Resultado: Antonio
                persona.["last" + nameKey]          Resultado: Gonzalez
                persona."first" + nameKey           Resultado: error
            Using brackets and prompt
                const interestedIn = prompt("What do you want to know about the person? Choose between fistName, lastName, age and friends")
                console.log(persona.interestedIn)           Resultado: Error
                console.log(persona[interestedIn])          Resultado(age): 55

Objects methods
    Any function that is attached to an object is called a "METHOD". Consists in use functions in objects
        const jonas = {
            firstName : "Jonas",
            lastName : "Perez",
            birthYear: 1992,
            hasDriversLicense: true,
        --> calcAge: function(birthYear){
                return 2021 - birthYear
            }
        }
    Accesing to the method
        jonas.calcAge(1991)
        jonas["calcAge"](1991)
    Accesing to the method with parameters inside the object
        const jonas = {
            firstName : "Jonas",
            lastName : "Perez",
            birthYear: 1992,
            hasDriversLicense: true,
        --> calcAge: function(){
                return 2021 - this.birthYear        //We use the word "THIS" to use a propierty inside the same object
            }
        }
    It is posible to use the name of the object instead of "this" but is not recomendable at all
        const jonas = { calcAge: function(){ return 2021 - jonas.birthYear } }
    Instead of calculate again and again the method, is better to calculate once and save in a variable inside the object
        const jonas = {
            firstName : "Jonas",
            lastName : "Perez",
            birthYear: 1992,
            hasDriversLicense: true,
        --> calcAge: function(){
                this.age = 2021 - this.birthYear
                return this.age
            }
        }
    --> Be carefull, it is necesarry first call the method and later we can call the return
        console.log(`The age of Jonas is ${jonas.age}`)             Resultado: The age of Jonas is Undefined
        jonas.calcAge()
        console.log(`The age of Jonas is ${jonas.age}`)             Resultado: The age of Jonas is 29
        console.log(`Jonas need work ${65 - jonas.age} years to retires`)

The FOR loop
    FOR loops keeps running while condition is TRUE
    Structure 
        for (let i = 0 ; i <= 10 ; i++){
            console.log(`What ever ${i}`)
        }
    Arrays
        for (let i = 0 ; ; i++){
            console.log(friends[i])
        }
        const numbers = [1, 2, 4, 56, 67, "numero", 128]
        let percentages = []
        for (let i = 0; i < numbers.length; i++) {
            percentages[i] = (numbers[i]/6)*100
                    The same is:
            percentages.push( (numbers[i]/6)*100 )
        }
    Continuing
        for (let i = 0; i < numbers.length; i++) {
            if (typeof numbers[i] === 'string') continue            //When number is a string, the loop continue but pass next.
            percentag[i] = (numbers[i] / 6) * 100
            console.log(number[i])                                  Resultado: 1, 2, 4, 56, 67, 128
        }
    Breaking
        for (let i = 0; i < numbers.length; i++) {
            if (numbers[i] == 4) break                  //When number = 4, the loop not continue
            percentages[i] = (numbers[i]/6)*100
            console.log(number[i])                      Resultado: 1, 2
        }
    Loop inside a loop
        for (let i = 1; i < 3; i++) {
            console.log(`Exercise ${i}`)
            for (let j = 1; j < 5; j++) {
                console.log(`Lifting repetition ${j}`)
            }
        }
    Backwards
        for (let i = 10; i > 7; i--) {
            console.log(i)                  Resultado: 10, 9, 8
        }

The WHILE loop
    Structure
        let rep = 1
        while (rep <= 10){
            console.log(`WHILE: Lifting repetition ${rep}`)
            rep++
        }
    WHILE loop is more versatile than FOR loop



---------------------- DEVELOPER SKILLS AND EDITOR SETUP ----------------------

Prettier
    on save, prettier apply formats like ";"
    It can be configurated creating a file called ".pretierrc" and putting settings like:
        {
            "tabWidth": 4,
            "singleQuote": true,
            "arrowParens": "avoid"
        }

Snippets
    Is a file where we can configure shortcuts like "console.log()" by ""
    Creating
        Preferences
        User Snippets
        New Global Snippets file
            We choose a name
    Structure
        "Print to console": {                           // Name of the Snippet
            "scope": "javascript,typescript",           // Used in
            "prefix": "cl",                             // When we type "cl" the snippet will be enabled
            "body": ["console.log($1);"],               // The reference of the snippet. "$1": put the cursor in this site 
            "description": "Log output to console"      // Description
        }
        
Settings Sync
    To Synchronice Setting along differents PCs or users

Live Server
    We can use a VS extension or use NodeJS wich is more professional, using npm package called Live Server
    1. Is necesary install NodeJs (google it and install)
    2. In terminal we write
        sudo npm install live-server -g
        live-server

Coding Challenges
    https://www.codewars.com
    Thousands of coding challenges

Problem solver
    1. Make sure you 100% understand the problem.
        Ask the right questions to get a clear picture of the problem.
    2. Divide and conquer
        Break a bif problem into smaller sub-problems
    3. Don't be afraid to do as much research as you have to.
        Google, Stack Overflow, MDN web docs.
    4. For bigger problems, write pseudo-code before writing the actual code.
        It's like code for humans to understand, not computers. It's not even JS, just schematic.

Debugging
    Find and fixing errors
    Software bug: defect or problem in a computer program. Basically, any unexpected or unintended behavior of a computer program is a software bug.
    Bugs are completely normal in software devvelopment
    Debugging: process of finding, fixing and preventing bugs.
    Debugging process
        Identify: becoming aware that there is a bug
            During development
            Testing software
            User reports during production
            Context: browsers, users, etc.
        Find: isolating where exactly the bug is happening in code
            Developer console (simply code)
            Debugger (complex code)
        Fix: correct the bug
            Replace wrong solution with new correct solution
        Prevent: preventing it form happening again
            Searching for the same bug in similar code
            Writing test using testing software

Debugging using the console
    Consist in prove and error

Debugger
    We use Chrome Inspect tool
        Click in Sources and user breakpoints: the breakpoints stops the JS code when we want and we can go step by step looking the code


---------------------- JS IN THE BROWSER: DOM AND EVENTS FUNDAMENTALS ----------------------

DOM
    Document Object Model: structured representation of HTML documents. Allows JS to access HTML elements and styles to manipulate them.
    We change text, change HTML attributes and even CSS styles.
    The DOM is bassically a conexion between HTML documents and JS code.
    The DOM is automatically created as soon as the browsers loads the HTML page and stores in a tree structure, and each of them is an object.
        <head>
            <section>
                <p>
                </p>
                <p>
                </p>
            </section>
        </head>
    DOM methods and propierties for DOM Manipulation (for example document.querySelector()) ARE NOT PART OF JS
    DOM methods and propierties (web API: application Programming Interface) CAN INTERACT WITH JS

Select the element
    document.querySelector('.message') ". and later we can write propierties"
    document.querySelector('#mensaje')
    
Event Listener
    .addEventListener(
        'click',                                        // It is necesary tell that the triggers the listener
        function () { console.log("Valor") }            // And what happen when the event is activated
        );
    const unaFuncion = function () {}
    .addEventListener('click', unaFuncion);
    Types of keyboard events
        KeyDown     ASA the key is pressed
        KeyUp       Once we put out the finger
        KeyPress    Continously

Standards
    In general, we call the classes or the IDs, and we stored this classes in variables, when later we use again and again
        const btn = document.querySelector(".button-show")
    When we use querySelector with multiple classes or elements, only select the first, in than case we use "querySelectorAll"
        const btn = document.querySelectorAll(".button-show")
        Once selected, we can use it similar than an Array
        for (let i = 0; i < btn.length; i++) {
            console.log(btn[i].textContent);
        }
    In real projects, adding and removing classes is the form of manipulation webs.
        This is because added and remove many styles in just one class
    If we need to call a function as soon as JS read/execute the line que put ()
        btn.addEventListener('click', openmodal);          // Wait for the click
        btn.addEventListener('click', openmodal());        // Inmediatly execute "closemodal"
        But, if the function is inside another function, then we write ()
        function(){
            openmodal();
        }
    Most common uses of classes
        btn.classList.add('hidden')
        btn.classList.remove('hidden')
        btn.classList.contains('hidden')
        btn.classList.toggle("hidden")      // If has the class, remove the class. If hasn't the class, added the class

Manipulating CSS styles
    document.querySelector('body').style ". and later the name of the propierty we want manipulate"
    document.querySelector('body').style
                                        .backgroundColor = '#60b347'
                                        .border  = "2px solid #fff"
                                        .fontSize = "25px"

Refactoring
    Eliminate duplicate code
    DRY principle: not repeat code
    Duplicate code:
        when we want to change some functionality, we have to chenge the same code in multiple places
        When we start coding, no big problem to start out with duplicate code
    Refactoring
        Restructure the code but without changing how it works, to improve the code and to eliminate duplicate code.
        1. Indentify duplicate code.

Modal Windows
    They are pop-ups windows, but in the same page, not new blanks.
    Structure
        <div class="modal hidden">                                  // Modal window class   (hidden -> display: none)
              <button class="close-modal">&times;</button>          // Close button
              <h1>I'm a modal window 😍</h1>                        // Title and text in the modal window
              <p>
                Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod
                tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim
                veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea
                commodo consequat. Duis aute irure dolor in reprehenderit in voluptate
                velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint
                occaecat cupidatat non proident, sunt in culpa qui officia deserunt
                mollit anim id est laborum.
              </p>
        </div>
        <div class="overlay hidden"></div>
    CSS
        display: none           // To hidden a element
        display: block          // To show a element in a block window


---------------------- HOW JS WORKS BEHING THE SCENES ----------------------

Deconstructing JS definition
    High-level
        Developers has NOT to manage resources manually(memory), everything is automatic.
    Garbage-collected
        Is basically an algorithm inside the JS engine wich automa removes old, unused objects from the memory.
    Interpreted or just-in-time compiled
        We write words ==> compiling ==> transform 0 and 1 ==> the computer understand only this 0 and 1
        In JS the compiling happens inside the JS engine
    Multi-paradigm
        Paradigm: an approach and mindset of structuring code, wich will direct your coding style and technique
        Three popular paradigms
            Procedural Programming
            Object-oriented Programming (OOP)
            Functional Programming (FP)
        Two different paradigms
            Imperative
            Declarative
    Prototype-based object-oriented
        The templates or the blueprint we use to create objects are the prototypes.
            Prototype
                Array.prototype.push
                Array.prototype.indexOf
            Build from prototype
                const arr = [1,2,3]
                arr.push(4)
                const hasZero = arr.indexOf(0) > 1
    First-class functions
        In a language with first-class functions, functions are simply treated as variables. We can pass them into other functions, and return them from functions.
            const funcion1 = function () {console.log("This is an example")}
            overlay.addEventListener("click", funcion1)
    Dynamic
        No data type definitions. Types becomes known at runtime
            let x = 23
        Data type of variable is automatically changed
            x = "palabra"
        But, if you want to use JS with types, use
            Typescript
    Single-threaded and Non-blocking event loop (Oversimplification!)
        Concurrency model: how the JavaScript engine handles multiple tasks happening at the same time.
        JavaScript runs in one single thread(piece of code), so it can only do one thing at a time.
        But what happen with long-running task? Sounds like it would block the single thread. However, we want non-blocking behavior!
        By using an event loop: takes long running tasks, executes them in the “background”, and puts them back in the main thread once they are finished.

The JS engine and runtime
    JS engine: computer program that executes JS code. Every browsers have his own JS engine. Chrome: V8 Engine with NodeJS
    JS engine contains
        Call Stack
            where our code is executed using something called Execution Context
        Heap
            where the objects are stored. Unstructured. Objects in memory
    Compilation vs interpretation
        Compilation: Entire code is converted into machine code at once, and written to a binary file that can be executed by a computer. Java
            Source code --Step1: Compilation--> Portable file(can be used in any computer): machine code --Step2: execution-->  Program running
                Step2: Can happen way after compilation
        Interpretation: Interpreter runs through the source code and executes it line by line. It is slower than compilated. Old JS
            Source code  --Step1: execution line by line--> Program running
                Step1: Code still needs to be converted to machine code
        Just-in-time (JIT) compilation: Entire code is converted into machine code at once, then executed immediately. Modern JS
            Source code --Step1: Compilation--> (Not Portable file) machine code --Step2: execution-->  Program running
                Step 2 Happens immediately
    Modern Just-in-Time compilation of JS
        Written code --AST--> Parsing --AST--> JiT Compilation ----> Execution ----> Optimization --(Loop during execution)-->JiT Compilation ---->
            AST(abstract syntax tree): representation of our entire code inside the engine
            Happens in special threads that we can’t access from code: Compilation, Execution, Parsing
            Happens in Call Stack: Execution
    JS Runtime in browsers
        Container including all the things that we need to use JS (in this case the browser)
        JS Engine
            Heap
            Call Stack
        Callback queue
            click, timer, data, etc
        Event Loop
            Take que callback queue event and throw it to the call stack
            Essential for non-blocking concurrency model
        Web APIs
            Functionalities provided to the engine, accesible on window object but not part of JS language itself
            DOM, Timers, fetch API, etc
    JS runtime in NodeJS
        Is very similar but since we don't have a browser, we can't have the web API. Instead we have multiple C++ binding and thread pool
        JS Engine
        Callback queue
        Event Loop
        C++ binding & thread pool

Execution context and the call stack
    Once the code is compiled, it execute:
    Execution
        1. Creation of global execution context (for top-level code(means NOT inside a function)). Function body only executed when called
            Execution context: abstract concept.
                Is an environment in which a piece of JavaScript is executed. 
                Stores all the necessary information for some code to be executed.
                Abstact example: pizza in a box
                    Box                     is the execution context for our pizza
                    Pizza                   the JS code to be executed
                    Fork, Knife, plate      things to execute the code
                In all JS projects(no matter how larger it is) has exactly one global execution context (EC)
                    Default context, created for code that is not inside any function (top-level).
        2. Execution of top-level code (inside global EC)
        3. Execution of functions and waiting for callbacks
                One execution context per function: For each function call, a new execution context is created.
    Execution context in detail
    --> What's inside execution context? <---- Generated during "creation phase", right before execution
            Variable environment
                let, const and var declarations
                Functions
                argument(NOT in arrow functions!) object 
            Scope chain
                References to variables that are located outside of the current function
            this keywork (NOT in arrow functions!)
        Example:
            const name = "Jonas"
            const first = () => {
                let a = 1
                const b ) second(7,9)
                a = a+b
                return a
            }
            function second(x,y){
                var c = 2
                return c
            }
            const x = first()
        Analizing example
            Global Execution Context    //literally the function code
                name = "Jonas"
                first = <function>
                second = <function>
                x = <unknown>           // Need to run first() first
            First() Execution context
                a = 1
                b = <unknown>           // Need to run second()
            Second() Execution context
                c = 2
                arguments = [7,9]       // Array of passed arguments. Available in all “regular” functions (not arrow)
        Call Stack      // “Place” where execution contexts get stacked on top of each other, to keep track of where we are in the execution
            second()    // Third Created. First execute
            first()     // Second Created. Second Execute
            Globak      // First Created. Thrid Execute
            The code is read line by line(once at same time: Single-thread) and this is why first declare functions and later we call it
                A function can't be called before created
                    var x = first()
                    const first = function () {console.log("Prueba")}       Resultado: Error
                First we create the function and later we call it
                    const first = function () {console.log("Prueba")}
                    var x = first()                                         Resultado: Prueba

Scope and The Scope Chain
    Definition
        Scoping: How our program’s variables are organized and accessed.
            Scoping ask the questions: “Where do variables live?” or “Where can we access a certain variable, and where not?”
        Lexical scoping: Scoping is controlled by placement of functions and blocks in the code.
            Variables in child function can access to variables in father function
    --> Scope: Space or environment in which a certain variable is declared (variable environment in case of functions).
            There is global scope, function scope, and block scope.
            In the case of functions is the same the scope and the variable environment of execution context.
        Scope of a variable: Region of our code where a certain variable can be accessed.
    Types of scope
        Global scope
            Outside of any function or block
            Variables declared in global scope are accessible everywhere
            Example:
                const x = 1
                const y = 2
                const a = "nombre"
        Function scope
            Variables are accessible only inside function, NOT outside
            Also called local scope
            Example:
                function (){
                    const z = 1
                    h = z + 3
                    return h
                }
                console.log(z)          // Resultado: Error
        Block Scope (ES6)
            Variables are accessible only inside block (block scoped)
            HOWEVER, this only applies to let and const variables!
            Functions are also block scoped (only in strict mode)
            Example:
                if (x < 5 && y = 2){
                    const coord = 25
                    var valor = true
                }
                console.log(coord)      // Resultado: Error
                console.log(valor)      // Resultado: true
    The Scope chain
        Es una cadena de alcance de las variables.
        Variable lookup in scope chain
            JS look from child to parents scopes, not from the other way. 
            Childs can acces to parents variable but parents can't acces to child variables
        const myName = "Jose"
        function first (){
            const age = 30          // Global variable
            if (age >= 30) {const decade = 3; var millenial = true}
            function second (){const job = "teacher"; console.log (`${myName} is a ${age}-olg ${job}`)}
            second()
        }
        first()
        Variable myName scope chain = all
        Variable age scope chain = first(), IF, second() 
        Variable decade scope chain = IF
        Variable millenial scope chain = first(), IF, second()
        Variable job scope chain = second()
        Access scope chain variables second() = nyName, age, millenial, job
        Access scope chain variables IF = myName, age, millenial, decade
        Access scope chain variables first() = age, millenial, nyName
        Access scope chain variables global = nyName
    Differences between Scope chain vs Call Stack
        Call Stack
            Is the order of execution
            In our example:
                second
                IF
                first
                global
        Scope Chain
            Is the acces of variables
            Has nothing to do with order in which functions were called!

Variable environment: hoisting and the TDZ
    Definition
        Hoisting: Makes some types of variables accessible/usable in the code before they are actually declared.“Variables magical lifted to the top of their scope”.
                ^
            BEHIND THE SCENES
                ^
        Before execution, code is scanned for variable declarations, and for each variable, a new property is created in the variable environment object.
    How it works hoisting
                                                Hoisted?                    Initial value               Scope
        function declarations                   Yes                         Actual function             Block (In strict mode. Otherwise: function!)
                We can use function declarations before they are actually declared in the code, because they are stored in the variable environment object even before the code starts executing
        var variables                           Yes                         Undefined                   Function
                If we want use a var variable before declaration, the variable has a initial value of "undefined", not an error. Common bugs, this is why in modern JS we don't use "var"
        let/const variables                     No in practice              <uninitialized>,TDZ         Block
                                                but yes technically         Temporally Dead Zone
                We say that these variables are placed in the TDZ. Which makes it so that we can't access the variables between the beginning of the scope and the plce where the variables are declared. In this case we have an error, not undefined.
        function expressions and arrows                     Depends if use var or let/const
    Temporal Dead Zone, let and const
        Example:
            const nyName = "Jose"
            if (myName === "Jose"){
            (1) console.log(`Jose is a ${job}`)
            (2) const age = 2021 - 1990
            (3) console.log(age)
            (4) const job = "farmer"
            (5) console.log(x)
            }
        TDZ for job variable is: (1)(2)(3). The variable didn't even exist.
            TDZ starts at the beginning of the scope until the line where it is defined
        (1) ReferenceError: Cannot access "job" before initialization ----> We try to acces before we define it
        (5) ReferenceError: x is not defined ----> variable X not created. It is in TDZ until his value is declared
    Why was created TDZ?
        Makes it easier to avoid and catch errors: accesing variables before declaration is bad practice and should be avoided.
        Makes const variables actually work. Because we can't define to "undefined"(like var) and later reassign with other value
    Why exists hoisting?
        Using functions before actual declaration
        Var hoisting is just a byproduct.

This keyword
    Definition
        this keyword/variable: Special variable that is created for every execution context (every function).
        Takes the value of (points to) the “owner” of the function in which the this keyword is used.
        this is NOT static. It depends on how the function is called, and its value is only assigned when the function is actually called.
        this does NOT point to the function itself, and also NOT the its variable environment!
    Examples of this to analyze
        Method ---->                        this = <Object that is calling the method>
            const persona = {
                name : "Jose"
                year: 1990
                calcAge : function {            // calcAge is method
                    return 2021 - this.year     // this = persona (same result as persona.year)
                }
            }
        Simple function call ---->          this = undefined (in strict mode. Otherwise(in the browser): window)
            Not attached to any object.
        Arrow functions ---->               this = <this of surrounding function (lexical this keyword)>
            Don't get their own "this keyword". The this function of the parent function
        Event listener ---->                this = <DOM element that the handler is attached to>
        new,call,apply,bind ---->           <Later in the course...>

Regular functions vs Arrow functions
    NEVER EVER use arrow functions as a method (function in object). The problem is "This keyword". The arrow functions haven't "This keyword".
        const amarillo = {
            firstName2: 'Antonio',
            greet: () => console.log(`Hey ${this.firstName2}`),
            greet2: function () { console.log(`Hey ${this.firstName2}`); },
        };
        amarillo.greet();                   // "Hey undefined". Amarillo object isn't a scope (global, function or block)
        var firstName2 = 'Matilda';         // If we have this variable in global scope. The arrow function can lead to error
        amarillo.greet();                   // "Hey Matilda". This happen because "this.firstName2" belongs to window object, NOT to amarillo object
        amarillo.greet2();                  // "Hey Antonio". Normal functions have YES "This keyword"
    Regular function called. Inside a regular function call, "This keyword" must be undefined
        const amarillo = {
            year: 1990,
            calcAge: function () {
                const isMillenial = function () {
                    console.log(this);              //undefined
                    console.log(this.year >= 1981 && this.year <= 1996);
                };
                isMillenial();                      // Regular function call. Resultado: TypeError: Cannot read property 'year' of undefined
            },
        };
        amarillo.calcAge(); //TypeError: Cannot read property 'year' of undefined
    Regular function called. Solutions
        Use "self" or "that". Before ES6
            calcAgeSelf: function () {
                const self = this; const that = this    // We use "self" or "that" like as a reminder of "This keyword"
                const isMillenial = function () {
                    console.log(self);                  // Object amarillo
                    console.log(that);                  // Object amarillo
                    console.log(`Self or that: ${self.year >= 1981 && self.year <= 1996}`);
                    console.log(`Self or that: ${that.year >= 1981 && that.year <= 1996}`);
                };
                isMillenial();                      // Regular function call. Resultado: true
            },
            Resultado: Self or that: true
    --> Use Arrow function. After ES6
            calcAgeArrow: function () {
                const isMillenial = () => {
                    console.log(this);
                    console.log(
                        `Arrow function: ${this.year >= 1981 && this.year <= 1996}`
                    );
                };
                isMillenial(); // Regular function call
            },
            Resultado: Arrow function: true
    Arguments keyword. Not important in moderns JS, use other ways
        Only available in regular functions
            const addExpr3 = function (a, b) {
                console.log('Arguments keyword:');
                console.log(arguments);                     // arguments YES exists
                return a + b;
            };
            addExpr3(3, 4);                                 // console.log = Array with arguments [3, 4]
            var addArrow2 = (a, b) => {
                console.log('Arguments keyword arrow:');
                console.log(arguments);                     // Not exists in arror functions
                return a + b;
            };
            addArrow2(3, 4);                                // Arguments is not defined

Primitives vs objects (primitive vs reference types)
    Primitives are stored in CALL STACK
        Primitive types: number, string, boolean, undefined, null, symbol, BigInt.
    Objects are stored in HEAP.
        Because objects might be too larg to be stored in the call stack, instead they are stored in the heap wich is like an almost unlimited memory pool
        Reference types: object literal, arrays, functions, etc
    Example:
        Primitives
            let age = 30;
            let oldAge = age;
            age = 31;
            console.log(age);                   // Resultado: 31
            console.log(oldAge);                // Resultado: 30
        Objects 
            const me = {
                name: 'Jose',
                age: 30,
            };
            const friend = me;
            friend.age = 27;
            console.log('Friend: ', friend);    // Resultado: 27
            console.log('Me: ', me);           // Resultado: 27            Here we see how we can change CONST value
    This happen because primitives are stored in differents memories and the object point into the same memory
        Primitives
            NAME            MEMORY          VALUE ADRESS
            Age             Memory 001      30 ==> 31
            oldAge          Memory 002      31
            So, when we change the value of Age, we change the value of Memory 001, but the Memory 002 not change
            Memory 001 -- Memory adress --> 30 ==> 31
            Memory 002 -- Memory adress --> 31
        Objects (Reference value)
            me ----> Memory 003 (30 ==> 27) <---- friend
            So, when we change the value of friend object, we change the value of Memory 003, wich is pointed by the 2 objects
            Memory 003 -- Memory adress --> D30F
    How to copy a new object and no modify the old object
        const NAME = Object.assign ( {} , OBJECT )
        const friend2 = Object.assign ( {} , me )
        Example:
            friend2.age = 27
            console.log(friend2.age)        // Resultado: 27
            console.log(me.age)             // Resultado: 30
        But only work in the first level. If we have a object inside an object, this way don't work.
            Both objects point to the same second level object
            To do a "deep clone" we use an externals libraries like "Lo-Dash"

3 more big topics of how JS works behind the scenes (for later..)
    Prototypal Inheritance:         Object Oriented Programming (OOP) With JavaScript               in Section 14
    Event Loop:                     Asynchronous JavaScript: Promises, Async/Await and AJAX         in Section 16
    How the DOM Really Works:       Advanced DOM and Events                                         in Section 13


---------------------- DATA STRUCTURES, MODERN OPERATORS AND STRINGS ----------------------

Which data structure to Use

