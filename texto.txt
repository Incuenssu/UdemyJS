Mozilla tutorial
    https://developer.mozilla.org/es/docs/Web/JavaScript

Cosas interesantes que saber
    const numNeighbours = prompt('How many neighbour countries does your country have?')
        Aparece un recuadro con la pregunta y guarda la variable en numNeighbours
    Si queremos quedarnos con solo 2 decimales en una cuenta usamos toFixed(Decimales)
        let n = (1441/7900)*100     Resultado: 18.240506329113924
        n = n.tofixed(2)            Resultado: 18.24
        console.log(percentageOfWorld1(population).toFixed(4))
    Para mover una linea hacia abajo/arriba en VS usamos ALT y la flecha abajo/arriba



---------------------- FUNDAMENTOS JS PARTE 1 ----------------------

How to use modern JS today
    ES5
        fully supported in all browsers (down to IE9 from 2011)
        Ready to be used today
    ES6/ES2015 to ES2020
        ES6+: well supported in all modern browsers
        No support in older browsers
        Can use most features in production with transpiling and polyfilling(Babel)
        Compatibility table: https://kangax.github.io/compat-table/es6/
    ES2021
        ESNext: future versions of the language (new feature proporsals that reach stage 4)
        Can already use some features in production with transpiling and polyfilling
    En este curso aprenderemos ES6 pero hay algunas cosas que saber en ES5(por ejemplo en ES5 se usaba var y en ES6+ se usa let y const).
        Es necesario para saber como funciona JS mejor
        Muchos tutoriales estan en ES5
        Cuando trabajemos en codebases antiguas, deben estar escritas en ES5

7 Primitive Data Types. But JS automatic detect the type of data of the value stored in a variable.
    Number: floating point number.
    String: sequence of characters.
    Boolean: true or false.
    Undefined: value taken by a variable that is not yet defined.
    Null: also means 'empty value'
    Symbol(ES2015): value that is unique and cannot be changed.
    BigInt (ES2020): larger integers than the number type can hold
    Podemos descubrir el tipo de data usando typeof
        typeof true     Resultado: Boolean

let, const and var
    Let(ES6): Variable that changes in future.
        let age;
        let age = 30;
    Const(ES6): Variable that will not change in the future.
        const birthYear = 1990;
        NOT ALLOWED const birthYear;
    Var: old way to define variables. Same use like "let"

Operators
    + - * / = !=
    Exponential(**): 2 ** 3 -> 2*2*2
    Contracciones(+=): por ejemplo x = 15;
        x += 10; x = 25
        x *= 2; x = 50
        x++; x= 51
    Comparison
        < <= > >=

Strings
    Ejemplo:
        const name = "Jonas";
        const year = 2021;
        const birthYear = 1990;
    Podemos concatenar strings
        const presentation = "I'm " + name + " and I have " + (year - birthYear) + " years old";
    Pero tambien podemos concatenar strings asi
        const newpresentation = ´I'm ${name} and I have ${year - birthYear} years old´
        OJO que no son ni "dobles" ni 'simples', es la de debajo del `exponencial`

Type Conversion and Coercion
    Conversion
        manually convert from one type to another
            const inputYear = '1990';
            console.log(inputYear + 18);                    Resultado: 199018
            console.log(Number(inputYear), inputYear)       Resultado: 1990 "1990"
            console.log(Number(inputYear) + 18)             Resultado: 2008
            console.log(Number('Jonas'))                    Resultado: NaN
    Coercion
        JS automatically converts types behind the scenes for us
            console.log('I am ' + 30 + ' years old')        JS transform "23" into a String
            console.log('23' - '10' - 3)                    Resultado: 10
            console.log('23' + '10' + 3)                    Resultado: 23103
            console.log('23' * '2')                         Resultado: 46
            console.log('23' > '18')                        Resultado: true
            Funciona para todos los operadores el cambio de string a number menos para la suma "+"
            let n = '1' + 1;    // 11
            n = n - 1;          // 10
            '10' - '4' - '3' - 2 + '5'      //15

Boolean Operators
    AND : &&
    OR : ||
    NOT : !== 
        bool = true; 
        !bool = false;

Switch Statement
    Se usa como IF pero cuando hay muchos casos, y en vez de usar ELSE IF continuamente usamos el esquema Switch
    Switch(day){
        case "monday":  // day === "monday"
            console.log("On monday, plan course structure.")
            console.log("Go to coding")
            break         Sin el break, el codigo continua ejecutandose. Si lo quitamos este break se ejecutaria monday y tuesday
        case "tuesday":
            console.log("On tuesday, ...")
            break
        case "wednesday":
        case "thursday":            //Si ponemos esta estructura de dos case seguidos, para ambos se ejecuta el console.log
            console.log("On wednesday and thursday, ...)
            break
        default:
            console.log("Para cuando no se cumple ningun caso")
    }
    Cada dia se usa menos, pero en ocasiones es mejor usarlo

Statement and Expresions
    Expresions: producen values. No generan acciones.
    Statements: no producen values. Generan acciones.
        if (23<10){                             Todo el if es un Statement
            const str = "23 isn't bigger"       Esto tambien es un Statement, pero el "23 isn't bigger" es una Expresion. y str tambien es una expresion
        }
    Es importante saber la diferencia porque JS permite usar Statements y Expresions o no.
        Ejemplo:
            console.log(`i am ${2020 - 1990} years old.`)                               Permitido
            console.log(`i am ${if(2020 > 1990) {const edad = "30"}} years old.`)       No permitido
    
The Conditional/Ternary Operator
    Es igual que el IF/ELSE pero todo en una linea
        const age = 30
            // Condicion ? Que pasa si true : que pasa si false
        age >= 18 ? console.log("I can drive.") : console.log("I can't drive.")
    La forma de usar el condicional realmente es:
        const drive = age >= 18 ? "can" : "can't"
        console.log(drive)
    Con IF/ELSE quedaria
        let drive
        if (age > 18){
            drive = "can"
        } else {
            drive = "can't"
        }
        console.log(drive)
    Pero como el Conditional es una expresion podemos aprovecharnos de ello
        console.log(`I ${const drive = age >= 18 ? "can" : "can't"} drive.`)
    


---------------------- FUNDAMENTOS JS PARTE 2 ----------------------

Strict mode
    It is a mode that will can enable in JS, it makes more secure write code
    To activate it, in the first line of the JS archive we write
        'use strict'
    It can be enabled and disabled for pieces of code
    Make it easier for us developers to avoid accidental errors. Help us introduce bus into our code.
        Stric mode forbids us to do certain things
        It will actually create visible errores for us in certain situations in wich without strict mode JS will simply fail silently.
    Example:
        let hasDriversLicense = false
        const passTest = true
        if (passTest) hasDriverLicense = true
        if (hasDriversLicense) console.log("I can't drive.")        Resultado: Nothing appears and no error is displayed
    Example 2:
        'use strict'
        let hasDriversLicense = false
        const passTest = true
        f (passTest) hasDriverLicense = true
        if (hasDriversLicense) console.log("I can't drive.")        Resultado: Appear an error in the console
    Strict mode also reserve some words
        let interface
        let private
        let if

Functions
    It is a piece of code that can be used over and over again in our code
    Creation function
        FUNCTION name (parameters) {}
        function loggger () {console.log("Hi")}
    Calling / running / invoking function
        NAME()
        logger()
    The functions have return of values
        function fruitProcessor(apples, oranges) {
            const juice = `Juice with ${apples} apples and ${oranges} oranges.`
            return juice
        }
        const applejuice = fruitProcessor(5, 4)     //We need to save the return in a variable or use directly, not calling the return.
        console.log(juice)                          Resultado: Error
        console.log(applejuice)                     Resultado: Juice with 5 apples and 4 oranges.
        console.log(fruitProcessor(9, 41))           Resultado: Juice with 9 apples and 41 oranges.

Function expresion and declaration
    Function declaration
        function calcAge1(birthYear){
            return 2020 - birthYear
        }
        const age1 = calcAge1(1990)
        console.log(age1)
    Function expresion
        const calcAge2 = function (birthYear){
                            return 2020 - birthYear
                         }
        const age2 = calcAge2(1990)
        console.log(age2)
    In declaration we can call first the variable and later the function, in expresion we can't do it
        const age2 = calcAge2(1990)
        const calcAge2 = function (birthYear){
                            return 2020 - birthYear
                         }
        Resultado: It don't works
        const age1 = calcAge1(1990)
        function calcAge1(birthYear){
            return 2020 - birthYear
        }
        Resultado: It works
    In practice, we can use both of them, it depends on the preference of the developer

Arrow functions
    Is a special form of function expression that is shorter and faster to write.
    Normal function:
        const calcAge2 = function (birthYear){
            return 2021 - birthYear
        }
    Arrow function:
        const calcAge3 = birthYear => 2021 - birthYear
        const age3 = calcAge3(1990)
        console.log(age3)
    If we need more complexity
        const yearsUntilRetirement = (birthYear, firstName) => {
            const age = 2021 - birthYear
            const retirement = 65 - age
            return `${firstName} retires in ${retirement} years`
        }
        console.log(yearsUntilRetirement(1990, "Jose Luis"))
    
Calling other Functions
    Example:
        let cutFruitPiece = fruit => fruit * 4
        function fruitProcessor (apples, oranges){
            const applePieces = cutFruitPiece(apples)       //applePieces = 2 * 4
            const orangePieces = cutFruitPiece(oranges)     //orangePieces = 3 * 4
            const juice = `Juice with ${applePieces} piece of apple and ${orangePieces} pieces of orange.`
            return juice
        }
        console.log(fruitProcessor(2,3))

Arrays
    Creation
        const friends = ["Jose Luis", "Pepito", "Pedro", "Horse Lluis"]
        const years = new Array (1990, 1991, 1992, 1993)
    Calling Arrays
        friends[0]
        years[3]
    Complexity
        const me = ["John", "Perez", 2021 - 1985, friends]      Array inside of a Array
    With functions
        const years = [1990, 1991, 1992, 1993]
        const calcAge = function (birthYear){
            return 2021 - birthYear
        }
        const ages = [calcAge(years[0]), calcAge(years[1]), calcAge[years(years.length])]
    Adding elements to the Array
        frients.push("Antonio")         Antonio is added to the end of the array
        friends.unshift("Pedrito")      Pedrito is added to the beginning of the array
    Removing elements to the Array
        friend.pop()                    The last element of the array will be removed
            const popped = years.pop()      Resultado(console.log): 1993
        friends.shift()                 The first element of the array will be removed
    Finding an element in the array
        friends.indexOF("Pepito")       Resultado(c.l): 1
        friends[friends.indexof("Pepito)] = "Pepe"

Objects
    structure
        const jonasArray = {
            //propierty : value
            firstName : "Jonas",
            lastName : "Perez",
            Age : 2021 - 1991,
            Job : "Teacher",
            Friend : ["Michael", "Peter", "Steven"]
        }
    Creating objects with functions
        const funcion = function (nombre, apellido, edad) {
            const objeto = {
                firstName: nombre,
                lastName: apellido,
                age: edad
            }
        return objeto
        }
        const persona = funcion("Antonio", "Gonzalez", 55)       Resultado: const objeto = {firstName: "Antonio", lastName: "Gonzalez", age: 55}
    DOT vs BRACKET notation
        DOT
            persona.name                         Resultado: Antonio
        BRACKET
            persona["name"]                      Resultado: Antonio
            Inside the brackets we can use any expresion.
                const nameKey = "Name"
                persona.["first" + nameKey]         Resultado: Antonio
                persona.["last" + nameKey]          Resultado: Gonzalez
                persona."first" + nameKey           Resultado: error
            Using brackets and prompt
                const interestedIn = prompt("What do you want to know about the person? Choose between fistName, lastName, age and friends")
                console.log(persona.interestedIn)           Resultado: Error
                console.log(persona[interestedIn])          Resultado(age): 55

Objects methods
    Any function that is attached to an object is called a "METHOD". Consists in use functions in objects
        const jonas = {
            firstName : "Jonas",
            lastName : "Perez",
            birthYear: 1992,
            hasDriversLicense: true,
        --> calcAge: function(birthYear){
                return 2021 - birthYear
            }
        }
    Accesing to the method
        jonas.calcAge(1991)
        jonas["calcAge"](1991)
    Accesing to the method with parameters inside the object
        const jonas = {
            firstName : "Jonas",
            lastName : "Perez",
            birthYear: 1992,
            hasDriversLicense: true,
        --> calcAge: function(){
                return 2021 - this.birthYear        //We use the word "THIS" to use a propierty inside the same object
            }
        }
    It is posible to use the name of the object instead of "this" but is not recomendable at all
        const jonas = { calcAge: function(){ return 2021 - jonas.birthYear } }
    Instead of calculate again and again the method, is better to calculate once and save in a variable inside the object
        const jonas = {
            firstName : "Jonas",
            lastName : "Perez",
            birthYear: 1992,
            hasDriversLicense: true,
        --> calcAge: function(){
                this.age = 2021 - this.birthYear
                return this.age
            }
        }
    --> Be carefull, it is necesarry first call the method and later we can call the return
        console.log(`The age of Jonas is ${jonas.age}`)             Resultado: The age of Jonas is Undefined
        jonas.calcAge()
        console.log(`The age of Jonas is ${jonas.age}`)             Resultado: The age of Jonas is 29
        console.log(`Jonas need work ${65 - jonas.age} years to retires`)

The FOR loop
    FOR loops keeps running while condition is TRUE
    Structure 
        for (let i = 0 ; i <= 10 ; i++){
            console.log(`What ever ${i}`)
        }
    Arrays
        for (let i = 0 ; ; i++){
            console.log(friends[i])
        }
        const numbers = [1, 2, 4, 56, 67, "numero", 128]
        let percentages = []
        for (let i = 0; i < numbers.length; i++) {
            percentages[i] = (numbers[i]/6)*100
                    The same is:
            percentages.push( (numbers[i]/6)*100 )
        }
    Continuing
        for (let i = 0; i < numbers.length; i++) {
            if (typeof numbers[i] === 'string') continue            //When number is a string, the loop continue but pass next.
            percentag[i] = (numbers[i] / 6) * 100
            console.log(number[i])                                  Resultado: 1, 2, 4, 56, 67, 128
        }
    Breaking
        for (let i = 0; i < numbers.length; i++) {
            if (numbers[i] == 4) break                  //When number = 4, the loop not continue
            percentages[i] = (numbers[i]/6)*100
            console.log(number[i])                      Resultado: 1, 2
        }
    Loop inside a loop
        for (let i = 1; i < 3; i++) {
            console.log(`Exercise ${i}`)
            for (let j = 1; j < 5; j++) {
                console.log(`Lifting repetition ${j}`)
            }
        }
    Backwards
        for (let i = 10; i > 7; i--) {
            console.log(i)                  Resultado: 10, 9, 8
        }

The WHILE loop
    Structure
        let rep = 1
        while (rep <= 10){
            console.log(`WHILE: Lifting repetition ${rep}`)
            rep++
        }
    WHILE loop is more versatile than FOR loop



---------------------- DEVELOPER SKILLS AND EDITOR SETUP ----------------------

Prettier
    on save, prettier apply formats like ";"
    It can be configurated creating a file called ".pretierrc" and putting settings like:
        {
            "tabWidth": 4,
            "singleQuote": true,
            "arrowParens": "avoid"
        }

Snippets
    Is a file where we can configure shortcuts like "console.log()" by ""
    Creating
        Preferences
        User Snippets
        New Global Snippets file
            We choose a name
    Structure
        "Print to console": {                           // Name of the Snippet
            "scope": "javascript,typescript",           // Used in
            "prefix": "cl",                             // When we type "cl" the snippet will be enabled
            "body": ["console.log($1);"],               // The reference of the snippet. "$1": put the cursor in this site 
            "description": "Log output to console"      // Description
        }
        
Settings Sync
    To Synchronice Setting along differents PCs or users

Live Server
    We can use a VS extension or use NodeJS wich is more professional, using npm package called Live Server
    1. Is necesary install NodeJs (google it and install)
    2. In terminal we write
        sudo npm install live-server -g
        live-server

Coding Challenges
    https://www.codewars.com
    Thousands of coding challenges

Problem solver
    1. Make sure you 100% understand the problem.
        Ask the right questions to get a clear picture of the problem.
    2. Divide and conquer
        Break a bif problem into smaller sub-problems
    3. Don't be afraid to do as much research as you have to.
        Google, Stack Overflow, MDN web docs.
    4. For bigger problems, write pseudo-code before writing the actual code.
        It's like code for humans to understand, not computers. It's not even JS, just schematic.

Debugging
    Find and fixing errors
    Software bug: defect or problem in a computer program. Basically, any unexpected or unintended behavior of a computer program is a software bug.
    Bugs are completely normal in software devvelopment
    Debugging: process of finding, fixing and preventing bugs.
    Debugging process
        Identify: becoming aware that there is a bug
            During development
            Testing software
            User reports during production
            Context: browsers, users, etc.
        Find: isolating where exactly the bug is happening in code
            Developer console (simply code)
            Debugger (complex code)
        Fix: correct the bug
            Replace wrong solution with new correct solution
        Prevent: preventing it form happening again
            Searching for the same bug in similar code
            Writing test using testing software

Debugging using the console
    Consist in prove and error

Debugger
    We use Chrome Inspect tool
        Click in Sources and user breakpoints: the breakpoints stops the JS code when we want and we can go step by step looking the code


---------------------- JS IN THE BROWSER: DOM AND EVENTS FUNDAMENTALS ----------------------

DOM
    Document Object Model: structured representation of HTML documents. Allows JS to access HTML elements and styles to manipulate them.
    We change text, change HTML attributes and even CSS styles.
    The DOM is bassically a conexion between HTML documents and JS code.
    The DOM is automatically created as soon as the browsers loads the HTML page and stores in a tree structure, and each of them is an object.
        <head>
            <section>
                <p>
                </p>
                <p>
                </p>
            </section>
        </head>
    DOM methods and propierties for DOM Manipulation (for example document.querySelector()) ARE NOT PART OF JS
    DOM methods and propierties (web API: application Programming Interface) CAN INTERACT WITH JS

Select the element
    document.querySelector('.message') ". and later we can write propierties"
    document.querySelector('#mensaje')
    
Event Listener
    .addEventListener(
        'click',                                        // It is necesary tell that the triggers the listener
        function () { console.log("Valor") }            // And what happen when the event is activated
        );
    const unaFuncion = function () {}
    .addEventListener('click', unaFuncion);

Manipulating CSS styles
    document.querySelector('body').style ". and later the name of the propierty we want manipulate"
    document.querySelector('body').style
                                        .backgroundColor = '#60b347'
                                        .border  = "2px solid #fff"
                                        .fontSize = "25px"

Refactoring
    Eliminate duplicate code
    DRY principle: not repeat code
    Duplicate code:
        when we want to change some functionality, we have to chenge the same code in multiple places
        When we start coding, no big problem to start out with duplicate code
    Refactoring
        Restructure the code but without changing how it works, to improve the code and to eliminate duplicate code.
        1. Indentify duplicate code.