Mozilla tutorial
    https://developer.mozilla.org/es/docs/Web/JavaScript

Cosas interesantes que saber
    const numNeighbours = prompt('How many neighbour countries does your country have?')
        Aparece un recuadro con la pregunta y guarda la variable en numNeighbours
    Si queremos quedarnos con solo 2 decimales en una cuenta usamos toFixed(Decimales)
        let n = (1441/7900)*100     Resultado: 18.240506329113924
        n = n.tofixed(2)            Resultado: 18.24
        console.log(percentageOfWorld1(population).toFixed(4))
    Para mover una linea hacia abajo/arriba en VS usamos ALT y la flecha abajo/arriba
    CONST es solo invariable para primitives(Primitive values) pero si son objetos(Reference values) si que podemos cambiar su valor.
        Primitives vs objects (primitive vs reference types)
    Metodo entries
        Es un array dentro de un array que contiene el valor y su posicion
            const array = ["Array1", "Array2", "Array3"]
            console.log([...array.entries()])
                [0, "Array1"]
                [1, "Array2"]
                [2, "Array3"]
        Ejemplo en For-Of en tema 09
    Timer. Tras unos milisegundos, se ejecutará una funcion
        setTimeout(FUNCION, MILISEGUNDOS);
        Tras 1000 milisegundos(1segundo), se ejecutará el console.log
        setTimeout(function() {console.log('Timer')}, 1000);
    When create a event listenin in a button, the web recharge, to prevent it:
        function(e){ e.preventDefault(); }
    Para modificar propiedades del CSS desde JS
        document.querySelector(" . # ").style.PROPIEDAD = VALOR
        document.querySelector(".textoPrincipal").style.opacity = 100
    Para zonas de texto usamos TEXTCONTENT
        document.querySelector(" . # ").textContent = "Texto nuevo"
    Para zonas donde el usuario puede escribir usamos VALUE
            document.querySelector(" . # ").value = "texto escrito"
        ++ incrementa el valor en 1 pero sigue devolviendo el valor previo si se pone detras, si se pone delante funciona correctamente
            let a = 10
            console.log(a++)                // Resultado: 10
                console.log(a)              // Resultado: 11
            console.log(++a)                // Resultado: 11
        Es mejor usar un link en vez de un boton para llamar a un modal, asi ira hacia donde queramos: top page, botton page, etc. Y asi evitamos problemas.
            <a class="nav__link nav__link--btn btn--show-modal" href="#"> Open account </a>
        getComputedStyle
            Para saber las propiedades del elemento incluso en el archivo css
        ":root{}" es el equivalente en CSS a "document." en JS
    Color random
        const randomInt = (min, max) =>
            Math.floor(Math.random() * (max - min + 1) + min);
        const randomColor = () =>
            `rgb(${randomInt(0, 255)},${randomInt(0, 255)},${randomInt(0, 255)})`;
        randomColor(0,255)
    Ver que ocasiona un evento: addEventListener("click", function(e){
        console.log( e.target ) })
    Para llevar a una seccion cuando se clicka un boton
        <a href="#section1"> Navegacion </a>        // id="section1"
    Barra de navegacion suave
        document.querySelector(PARENT).addEventListener('click', function (e) {
            e.preventDefault();
            const clicked = e.target.classList.contains(CHILD);
            if (!clicked) return;
            document
                .querySelector(e.target.getAttribute('href'))
                .scrollIntoView({ behavior: 'smooth' });
        });
    querySelector busca hijos no importa lo profundos que esten
    closest busca padres no importa lo profundos que esten
    Hover
        El opuesto a mouseenter is mouseleave
        El opuesto a mouseover is mouseout
    Funcion para hacer semitransparente el resto de botones de navegacion cuando Hover. (Passing arguments to event handlers)
        const nav = document.querySelector('.nav');
        const handleHover = function (e) {
            if (e.target.classList.contains('nav__link')) {
                const link = e.target;
                const siblings = link.closest('nav').querySelectorAll('.nav__link');
                const logo = link.closest('.nav').querySelector('img');
                siblings.forEach(el => {
                    if (el !== link) el.style.opacity = this;
                    logo.style.opacity = this;
                });
            }
        };
        nav.addEventListener('mouseover', handleHover.bind(0.5));
        nav.addEventListener('mouseout', handleHover.bind(1));
    Sticky navigation barra En el CSS le aplicamos el estilo
        .nav.sticky {
            position: fixed;
        }
    Para hacer aparecer y desaperecer cosas cuando pasan por un determinado punto
        Creacion
            const observer = new IntersectionObserver(observerCallBack, observerOptions);
            const navHeight = qs(".nav").getBoundingClientRect().height;
        Funcion
            const observerCallBack = function (entries) {
                const [entry] = entries;
                if (!entry.isIntersecting) qs(".navbar").classList.add('sticky');
                else qs(".navbar").classList.remove('sticky');
            };
        Opciones
            const observerOptions = {
                root: null,
                threshold: 0,
                rootMargin: `-${navHeight}px`,
            };
        Llamando al observador
            observer.observe(qs('.header'));





---------------------- FUNDAMENTOS JS PARTE 1 ----------------------

How to use modern JS today
    ES5
        fully supported in all browsers (down to IE9 from 2011)
        Ready to be used today
    ES6/ES2015 to ES2020
        ES6+: well supported in all modern browsers
        No support in older browsers
        Can use most features in production with transpiling and polyfilling(Babel)
        Compatibility table: https://kangax.github.io/compat-table/es6/
    ES2021
        ESNext: future versions of the language (new feature proporsals that reach stage 4)
        Can already use some features in production with transpiling and polyfilling
    En este curso aprenderemos ES6 pero hay algunas cosas que saber en ES5(por ejemplo en ES5 se usaba var y en ES6+ se usa let y const).
        Es necesario para saber como funciona JS mejor
        Muchos tutoriales estan en ES5
        Cuando trabajemos en codebases antiguas, deben estar escritas en ES5

7 Primitive Data Types. But JS automatic detect the type of data of the value stored in a variable.
    Number: floating point number.
    String: sequence of characters.
    Boolean: true or false.
    Undefined: value taken by a variable that is not yet defined.
    Null: also means 'empty value'
    Symbol(ES2015): value that is unique and cannot be changed.
    BigInt (ES2020): larger integers than the number type can hold
    Podemos descubrir el tipo de data usando typeof
        typeof true     Resultado: Boolean

let, const and var
    Let(ES6): Variable that changes in future.
        let age;
        let age = 30;
    Const(ES6): Variable that will not change in the future.
        const birthYear = 1990;
        NOT ALLOWED const birthYear;
    Var: old way to define variables. Same use like "let"

Operators
    + - * / = !=
    Exponential(**): 2 ** 3 -> 2*2*2
    Contracciones(+=): por ejemplo x = 15;
        x += 10; x = 25
        x *= 2; x = 50
        x++; x= 51
    Comparison
        < <= > >=

Strings
    Ejemplo:
        const name = "Jonas";
        const year = 2021;
        const birthYear = 1990;
    Podemos concatenar strings
        const presentation = "I'm " + name + " and I have " + (year - birthYear) + " years old";
    Pero tambien podemos concatenar strings asi
        const newpresentation = ´I'm ${name} and I have ${year - birthYear} years old´
        OJO que no son ni "dobles" ni 'simples', es la de debajo del `exponencial`

Type Conversion and Coercion
    Conversion
        manually convert from one type to another
            const inputYear = '1990';
            console.log(inputYear + 18);                    Resultado: 199018
            console.log(Number(inputYear), inputYear)       Resultado: 1990 "1990"
            console.log(Number(inputYear) + 18)             Resultado: 2008
            console.log(Number('Jonas'))                    Resultado: NaN
    Coercion
        JS automatically converts types behind the scenes for us
            console.log('I am ' + 30 + ' years old')        JS transform "23" into a String
            console.log('23' - '10' - 3)                    Resultado: 10
            console.log('23' + '10' + 3)                    Resultado: 23103
            console.log('23' * '2')                         Resultado: 46
            console.log('23' > '18')                        Resultado: true
            Funciona para todos los operadores el cambio de string a number menos para la suma "+"
            let n = '1' + 1;    // 11
            n = n - 1;          // 10
            '10' - '4' - '3' - 2 + '5'      //15

Boolean Operators
    AND : &&
    OR : ||
    NOT : !== 
        bool = true; 
        !bool = false;

Switch Statement
    Se usa como IF pero cuando hay muchos casos, y en vez de usar ELSE IF continuamente usamos el esquema Switch
    Switch(day){
        case "monday":  // day === "monday"
            console.log("On monday, plan course structure.")
            console.log("Go to coding")
            break         Sin el break, el codigo continua ejecutandose. Si lo quitamos este break se ejecutaria monday y tuesday
        case "tuesday":
            console.log("On tuesday, ...")
            break
        case "wednesday":
        case "thursday":            //Si ponemos esta estructura de dos case seguidos, para ambos se ejecuta el console.log
            console.log("On wednesday and thursday, ...)
            break
        default:
            console.log("Para cuando no se cumple ningun caso")
    }
    Cada dia se usa menos, pero en ocasiones es mejor usarlo

Statement and Expresions
    Expresions: producen values. No generan acciones.
    Statements: no producen values. Generan acciones.
        if (23<10){                             Todo el if es un Statement
            const str = "23 isn't bigger"       Esto tambien es un Statement, pero el "23 isn't bigger" es una Expresion. y str tambien es una expresion
        }
    Es importante saber la diferencia porque JS permite usar Statements y Expresions o no.
        Ejemplo:
            console.log(`i am ${2020 - 1990} years old.`)                               Permitido
            console.log(`i am ${if(2020 > 1990) {const edad = "30"}} years old.`)       No permitido
    
The Conditional/Ternary Operator
    Is the same than IF/ELSE but all in one line
        const age = 30
            // Condicion ? "what happen if TRUE" : "what happen if FALSE"
        age >= 18 ? console.log("I can drive.") : console.log("I can't drive.")
    La forma de usar el condicional realmente es:
        const drive = age >= 18 ? "can" : "can't"
        console.log(drive)
    Con IF/ELSE quedaria
        let drive
        if (age > 18){
            drive = "can"
        } else {
            drive = "can't"
        }
        console.log(drive)
    Pero como el Conditional es una expresion podemos aprovecharnos de ello
        console.log(`I ${const drive = age >= 18 ? "can" : "can't"} drive.`)
    

---------------------- FUNDAMENTOS JS PARTE 2 ----------------------

Strict mode
    It is a mode that will can enable in JS, it makes more secure write code
    To activate it, in the first line of the JS archive we write
        'use strict'
    It can be enabled and disabled for pieces of code
    Make it easier for us developers to avoid accidental errors. Help us introduce bus into our code.
        Stric mode forbids us to do certain things
        It will actually create visible errores for us in certain situations in wich without strict mode JS will simply fail silently.
    Example:
        let hasDriversLicense = false
        const passTest = true
        if (passTest) hasDriverLicense = true
        if (hasDriversLicense) console.log("I can't drive.")        Resultado: Nothing appears and no error is displayed
    Example 2:
        'use strict'
        let hasDriversLicense = false
        const passTest = true
        f (passTest) hasDriverLicense = true
        if (hasDriversLicense) console.log("I can't drive.")        Resultado: Appear an error in the console
    Strict mode also reserve some words
        let interface
        let private
        let if

Functions
    It is a piece of code that can be used over and over again in our code
    Creation function
        FUNCTION name (parameters) {}
        function loggger () {console.log("Hi")}
    Calling / running / invoking function
        NAME()
        logger()
    The functions have return of values
        function fruitProcessor(apples, oranges) {
            const juice = `Juice with ${apples} apples and ${oranges} oranges.`
            return juice
        }
        const applejuice = fruitProcessor(5, 4)     //We need to save the return in a variable or use directly, not calling the return.
        console.log(juice)                          Resultado: Error
        console.log(applejuice)                     Resultado: Juice with 5 apples and 4 oranges.
        console.log(fruitProcessor(9, 41))           Resultado: Juice with 9 apples and 41 oranges.

Function expresion and declaration
    Function declaration
        function calcAge1(birthYear){
            return 2020 - birthYear
        }
        const age1 = calcAge1(1990)
        console.log(age1)
    Function expresion
        const calcAge2 = function (birthYear){
                            return 2020 - birthYear
                         }
        const age2 = calcAge2(1990)
        console.log(age2)
    In declaration we can call first the variable and later the function, in expresion we can't do it
        const age2 = calcAge2(1990)
        const calcAge2 = function (birthYear){
                            return 2020 - birthYear
                         }
        Resultado: It don't works
        const age1 = calcAge1(1990)
        function calcAge1(birthYear){
            return 2020 - birthYear
        }
        Resultado: It works
    In practice, we can use both of them, it depends on the preference of the developer

Arrow functions
    Is a special form of function expression that is shorter and faster to write.
    Normal function:
        const calcAge2 = function (birthYear){
            return 2021 - birthYear
        }
    Arrow function:
        const calcAge3 = birthYear => 2021 - birthYear
        const age3 = calcAge3(1990)
        console.log(age3)
    If we need more complexity
        const yearsUntilRetirement = (birthYear, firstName) => {
            const age = 2021 - birthYear
            const retirement = 65 - age
            return `${firstName} retires in ${retirement} years`
        }
        console.log(yearsUntilRetirement(1990, "Jose Luis"))
    
Calling other Functions
    Example:
        let cutFruitPiece = fruit => fruit * 4
        function fruitProcessor (apples, oranges){
            const applePieces = cutFruitPiece(apples)       //applePieces = 2 * 4
            const orangePieces = cutFruitPiece(oranges)     //orangePieces = 3 * 4
            const juice = `Juice with ${applePieces} piece of apple and ${orangePieces} pieces of orange.`
            return juice
        }
        console.log(fruitProcessor(2,3))

Arrays
    Creation
        const friends = ["Jose Luis", "Pepito", "Pedro", "Horse Lluis"]
        const years = new Array (1990, 1991, 1992, 1993)
    Calling Arrays
        friends[0]
        years[3]
    Complexity
        const me = ["John", "Perez", 2021 - 1985, friends]      Array inside of a Array
    With functions
        const years = [1990, 1991, 1992, 1993]
        const calcAge = function (birthYear){
            return 2021 - birthYear
        }
        const ages = [calcAge(years[0]), calcAge(years[1]), calcAge[years(years.length])]
    Adding elements to the Array
        frients.push("Antonio")         Antonio is added to the end of the array
        friends.unshift("Pedrito")      Pedrito is added to the beginning of the array
    Removing elements to the Array
        friend.pop()                    The last element of the array will be removed
            const popped = years.pop()      Resultado(console.log): 1993
        friends.shift()                 The first element of the array will be removed
    Finding an element in the array
        friends.indexOF("Pepito")       Resultado(c.l): 1
        friends[friends.indexof("Pepito)] = "Pepe"

Objects
    structure
        const jonasArray = {
            //propierty : value
            firstName : "Jonas",
            lastName : "Perez",
            Age : 2021 - 1991,
            Job : "Teacher",
            Friend : ["Michael", "Peter", "Steven"]
        }
    Creating objects with functions
        const funcion = function (nombre, apellido, edad) {
            const objeto = {
                firstName: nombre,
                lastName: apellido,
                age: edad
            }
        return objeto
        }
        const persona = funcion("Antonio", "Gonzalez", 55)       Resultado: const objeto = {firstName: "Antonio", lastName: "Gonzalez", age: 55}
    DOT vs BRACKET notation
        DOT
            persona.name                         Resultado: Antonio
        BRACKET
            persona["name"]                      Resultado: Antonio
            Inside the brackets we can use any expresion.
                const nameKey = "Name"
                persona.["first" + nameKey]         Resultado: Antonio
                persona.["last" + nameKey]          Resultado: Gonzalez
                persona."first" + nameKey           Resultado: error
            Using brackets and prompt
                const interestedIn = prompt("What do you want to know about the person? Choose between fistName, lastName, age and friends")
                console.log(persona.interestedIn)           Resultado: Error
                console.log(persona[interestedIn])          Resultado(age): 55

Objects methods
    Any function that is attached to an object is called a "METHOD". Consists in use functions in objects
        const jonas = {
            firstName : "Jonas",
            lastName : "Perez",
            birthYear: 1992,
            hasDriversLicense: true,
        --> calcAge: function(birthYear){
                return 2021 - birthYear
            }
        }
    Accesing to the method
        jonas.calcAge(1991)
        jonas["calcAge"](1991)
    Accesing to the method with parameters inside the object
        const jonas = {
            firstName : "Jonas",
            lastName : "Perez",
            birthYear: 1992,
            hasDriversLicense: true,
        --> calcAge: function(){
                return 2021 - this.birthYear        //We use the word "THIS" to use a propierty inside the same object
            }
        }
    It is posible to use the name of the object instead of "this" but is not recomendable at all
        const jonas = { calcAge: function(){ return 2021 - jonas.birthYear } }
    Instead of calculate again and again the method, is better to calculate once and save in a variable inside the object
        const jonas = {
            firstName : "Jonas",
            lastName : "Perez",
            birthYear: 1992,
            hasDriversLicense: true,
        --> calcAge: function(){
                this.age = 2021 - this.birthYear
                return this.age
            }
        }
    --> Be carefull, it is necesary first call the method and later we can call the return
        console.log(`The age of Jonas is ${jonas.age}`)             Resultado: The age of Jonas is Undefined
        jonas.calcAge()
        console.log(`The age of Jonas is ${jonas.age}`)             Resultado: The age of Jonas is 29
        console.log(`Jonas need work ${65 - jonas.age} years to retires`)

The FOR loop
    FOR loops keeps running while condition is TRUE
    Structure 
        for (let i = 0 ; i <= 10 ; i++){
            console.log(`What ever ${i}`)
        }
    Arrays
        for (let i = 0 ; ; i++){
            console.log(friends[i])
        }
        const numbers = [1, 2, 4, 56, 67, "numero", 128]
        let percentages = []
        for (let i = 0; i < numbers.length; i++) {
            percentages[i] = (numbers[i]/6)*100
                    The same is:
            percentages.push( (numbers[i]/6)*100 )
        }
    Continuing
        for (let i = 0; i < numbers.length; i++) {
            if (typeof numbers[i] === 'string') continue            //When number is a string, the loop continue but pass next.
            percentag[i] = (numbers[i] / 6) * 100
            console.log(number[i])                                  Resultado: 1, 2, 4, 56, 67, 128
        }
    Breaking
        for (let i = 0; i < numbers.length; i++) {
            if (numbers[i] == 4) break                  //When number = 4, the loop not continue
            percentages[i] = (numbers[i]/6)*100
            console.log(number[i])                      Resultado: 1, 2
        }
    Loop inside a loop
        for (let i = 1; i < 3; i++) {
            console.log(`Exercise ${i}`)
            for (let j = 1; j < 5; j++) {
                console.log(`Lifting repetition ${j}`)
            }
        }
    Backwards
        for (let i = 10; i > 7; i--) {
            console.log(i)                  Resultado: 10, 9, 8
        }

The WHILE loop
    Structure
        let rep = 1
        while (rep <= 10){
            console.log(`WHILE: Lifting repetition ${rep}`)
            rep++
        }
    WHILE loop is more versatile than FOR loop


---------------------- DEVELOPER SKILLS AND EDITOR SETUP ----------------------

Prettier
    on save, prettier apply formats like ";"
    It can be configurated creating a file called ".pretierrc" and putting settings like:
        {
            "tabWidth": 4,
            "singleQuote": true,
            "arrowParens": "avoid"
        }

Snippets
    Is a file where we can configure shortcuts like "console.log()" by ""
    Creating
        Preferences
        User Snippets
        New Global Snippets file
            We choose a name
    Structure
        "Print to console": {                           // Name of the Snippet
            "scope": "javascript,typescript",           // Used in
            "prefix": "cl",                             // When we type "cl" the snippet will be enabled
            "body": ["console.log($1);"],               // The reference of the snippet. "$1": put the cursor in this site 
            "description": "Log output to console"      // Description
        }
        
Settings Sync
    To Synchronice Setting along differents PCs or users

Live Server
    We can use a VS extension or use NodeJS wich is more professional, using npm package called Live Server
    1. Is necesary install NodeJs (google it and install)
    2. In terminal we write
        sudo npm install live-server -g
        live-server

Coding Challenges
    https://www.codewars.com
    Thousands of coding challenges

Problem solver
    1. Make sure you 100% understand the problem.
        Ask the right questions to get a clear picture of the problem.
    2. Divide and conquer
        Break a bif problem into smaller sub-problems
    3. Don't be afraid to do as much research as you have to.
        Google, Stack Overflow, MDN web docs.
    4. For bigger problems, write pseudo-code before writing the actual code.
        It's like code for humans to understand, not computers. It's not even JS, just schematic.

Debugging
    Find and fixing errors
    Software bug: defect or problem in a computer program. Basically, any unexpected or unintended behavior of a computer program is a software bug.
    Bugs are completely normal in software devvelopment
    Debugging: process of finding, fixing and preventing bugs.
    Debugging process
        Identify: becoming aware that there is a bug
            During development
            Testing software
            User reports during production
            Context: browsers, users, etc.
        Find: isolating where exactly the bug is happening in code
            Developer console (simply code)
            Debugger (complex code)
        Fix: correct the bug
            Replace wrong solution with new correct solution
        Prevent: preventing it form happening again
            Searching for the same bug in similar code
            Writing test using testing software

Debugging using the console
    Consist in prove and error

Debugger
    We use Chrome Inspect tool
        Click in Sources and user breakpoints: the breakpoints stops the JS code when we want and we can go step by step looking the code


---------------------- JS IN THE BROWSER: DOM AND EVENTS FUNDAMENTALS ----------------------

DOM
    Document Object Model: structured representation of HTML documents. Allows JS to access HTML elements and styles to manipulate them.
    We change text, change HTML attributes and even CSS styles.
    The DOM is bassically a conexion between HTML documents and JS code.
    The DOM is automatically created as soon as the browsers loads the HTML page and stores in a tree structure, and each of them is an object.
        <head>
            <section>
                <p>
                </p>
                <p>
                </p>
            </section>
        </head>
    DOM methods and propierties for DOM Manipulation (for example document.querySelector()) ARE NOT PART OF JS
    DOM methods and propierties (web API: application Programming Interface) CAN INTERACT WITH JS

Select the element
    document.querySelector('.message') ". and later we can write propierties"
    document.querySelector('#mensaje')
    
Event Listener
    .addEventListener(
        'click',                                        // It is necesary tell that the triggers the listener
        function () { console.log("Valor") }            // And what happen when the event is activated
        );
    const unaFuncion = function () {}
    .addEventListener('click', unaFuncion);
    Types of keyboard events
        KeyDown     ASA the key is pressed
        KeyUp       Once we put out the finger
        KeyPress    Continously

Standards
    In general, we call the classes or the IDs, and we stored this classes in variables, when later we use again and again
        const btn = document.querySelector(".button-show")
    When we use querySelector with multiple classes or elements, only select the first, in than case we use "querySelectorAll"
        const btn = document.querySelectorAll(".button-show")
        Once selected, we can use it similar than an Array
        for (let i = 0; i < btn.length; i++) {
            console.log(btn[i].textContent);
        }
    In real projects, adding and removing classes is the form of manipulation webs.
        This is because added and remove many styles in just one class
    If we need to call a function as soon as JS read/execute the line que put ()
        btn.addEventListener('click', openmodal);          // Wait for the click
        btn.addEventListener('click', openmodal());        // Inmediatly execute "closemodal"
        But, if the function is inside another function, then we write ()
        function(){
            openmodal();
        }
    Most common uses of classes
        btn.classList.add('hidden')
        btn.classList.remove('hidden')
        btn.classList.contains('hidden')
        btn.classList.toggle("hidden")      // If has the class, remove the class. If hasn't the class, added the class

Manipulating CSS styles
    document.querySelector('body').style ". and later the name of the propierty we want manipulate"
    document.querySelector('body').style
                                        .backgroundColor = '#60b347'
                                        .border  = "2px solid #fff"
                                        .fontSize = "25px"

Refactoring
    Eliminate duplicate code
    DRY principle: not repeat code
    Duplicate code:
        when we want to change some functionality, we have to chenge the same code in multiple places
        When we start coding, no big problem to start out with duplicate code
    Refactoring
        Restructure the code but without changing how it works, to improve the code and to eliminate duplicate code.
        1. Indentify duplicate code.

Modal Windows
    They are pop-ups windows, but in the same page, not new blanks.
    Structure
        <div class="modal hidden">                                  // Modal window class   (hidden -> display: none)
              <button class="close-modal">&times;</button>          // Close button
              <h1>I'm a modal window 😍</h1>                        // Title and text in the modal window
              <p>
                Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod
                tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim
                veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea
                commodo consequat. Duis aute irure dolor in reprehenderit in voluptate
                velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint
                occaecat cupidatat non proident, sunt in culpa qui officia deserunt
                mollit anim id est laborum.
              </p>
        </div>
        <div class="overlay hidden"></div>
    CSS
        display: none           // To hidden a element
        display: block          // To show a element in a block window


---------------------- HOW JS WORKS BEHING THE SCENES ----------------------

Deconstructing JS definition
    High-level
        Developers has NOT to manage resources manually(memory), everything is automatic.
    Garbage-collected
        Is basically an algorithm inside the JS engine wich automa removes old, unused objects from the memory.
    Interpreted or just-in-time compiled
        We write words ==> compiling ==> transform 0 and 1 ==> the computer understand only this 0 and 1
        In JS the compiling happens inside the JS engine
    Multi-paradigm
        Paradigm: an approach and mindset of structuring code, wich will direct your coding style and technique
        Three popular paradigms
            Procedural Programming
            Object-oriented Programming (OOP)
            Functional Programming (FP)
        Two different paradigms
            Imperative
            Declarative
    Prototype-based object-oriented
        The templates or the blueprint we use to create objects are the prototypes.
            Prototype
                Array.prototype.push
                Array.prototype.indexOf
            Build from prototype
                const arr = [1,2,3]
                arr.push(4)
                const hasZero = arr.indexOf(0) > 1
    First-class functions
        In a language with first-class functions, functions are simply treated as variables. We can pass them into other functions, and return them from functions.
            const funcion1 = function () {console.log("This is an example")}
            overlay.addEventListener("click", funcion1)
    Dynamic
        No data type definitions. Types becomes known at runtime
            let x = 23
        Data type of variable is automatically changed
            x = "palabra"
        But, if you want to use JS with types, use
            Typescript
    Single-threaded and Non-blocking event loop (Oversimplification!)
        Concurrency model: how the JavaScript engine handles multiple tasks happening at the same time.
        JavaScript runs in one single thread(piece of code), so it can only do one thing at a time.
        But what happen with long-running task? Sounds like it would block the single thread. However, we want non-blocking behavior!
        By using an event loop: takes long running tasks, executes them in the “background”, and puts them back in the main thread once they are finished.

The JS engine and runtime
    JS engine: computer program that executes JS code. Every browsers have his own JS engine. Chrome: V8 Engine with NodeJS
    JS engine contains
        Call Stack
            where our code is executed using something called Execution Context
        Heap
            where the objects are stored. Unstructured. Objects in memory
    Compilation vs interpretation
        Compilation: Entire code is converted into machine code at once, and written to a binary file that can be executed by a computer. Java
            Source code --Step1: Compilation--> Portable file(can be used in any computer): machine code --Step2: execution-->  Program running
                Step2: Can happen way after compilation
        Interpretation: Interpreter runs through the source code and executes it line by line. It is slower than compilated. Old JS
            Source code  --Step1: execution line by line--> Program running
                Step1: Code still needs to be converted to machine code
        Just-in-time (JIT) compilation: Entire code is converted into machine code at once, then executed immediately. Modern JS
            Source code --Step1: Compilation--> (Not Portable file) machine code --Step2: execution-->  Program running
                Step 2 Happens immediately
    Modern Just-in-Time compilation of JS
        Written code --AST--> Parsing --AST--> JiT Compilation ----> Execution ----> Optimization --(Loop during execution)-->JiT Compilation ---->
            AST(abstract syntax tree): representation of our entire code inside the engine
            Happens in special threads that we can’t access from code: Compilation, Execution, Parsing
            Happens in Call Stack: Execution
    JS Runtime in browsers
        Container including all the things that we need to use JS (in this case the browser)
        JS Engine
            Heap
            Call Stack
        Callback queue
            click, timer, data, etc
        Event Loop
            Take que callback queue event and throw it to the call stack
            Essential for non-blocking concurrency model
        Web APIs
            Functionalities provided to the engine, accesible on window object but not part of JS language itself
            DOM, Timers, fetch API, etc
    JS runtime in NodeJS
        Is very similar but since we don't have a browser, we can't have the web API. Instead we have multiple C++ binding and thread pool
        JS Engine
        Callback queue
        Event Loop
        C++ binding & thread pool

Execution context and the call stack
    Once the code is compiled, it execute:
    Execution
        1. Creation of global execution context (for top-level code(means NOT inside a function)). Function body only executed when called
            Execution context: abstract concept.
                Is an environment in which a piece of JavaScript is executed. 
                Stores all the necessary information for some code to be executed.
                Abstact example: pizza in a box
                    Box                     is the execution context for our pizza
                    Pizza                   the JS code to be executed
                    Fork, Knife, plate      things to execute the code
                In all JS projects(no matter how larger it is) has exactly one global execution context (EC)
                    Default context, created for code that is not inside any function (top-level).
        2. Execution of top-level code (inside global EC)
        3. Execution of functions and waiting for callbacks
                One execution context per function: For each function call, a new execution context is created.
    Execution context in detail
    --> What's inside execution context? <---- Generated during "creation phase", right before execution
            Variable environment
                let, const and var declarations
                Functions
                argument(NOT in arrow functions!) object 
            Scope chain
                References to variables that are located outside of the current function
            this keywork (NOT in arrow functions!)
        Example:
            const name = "Jonas"
            const first = () => {
                let a = 1
                const b ) second(7,9)
                a = a+b
                return a
            }
            function second(x,y){
                var c = 2
                return c
            }
            const x = first()
        Analizing example
            Global Execution Context    //literally the function code
                name = "Jonas"
                first = <function>
                second = <function>
                x = <unknown>           // Need to run first() first
            First() Execution context
                a = 1
                b = <unknown>           // Need to run second()
            Second() Execution context
                c = 2
                arguments = [7,9]       // Array of passed arguments. Available in all “regular” functions (not arrow)
        Call Stack      // “Place” where execution contexts get stacked on top of each other, to keep track of where we are in the execution
            second()    // Third Created. First execute
            first()     // Second Created. Second Execute
            Globak      // First Created. Thrid Execute
            The code is read line by line(once at same time: Single-thread) and this is why first declare functions and later we call it
                A function can't be called before created
                    var x = first()
                    const first = function () {console.log("Prueba")}       Resultado: Error
                First we create the function and later we call it
                    const first = function () {console.log("Prueba")}
                    var x = first()                                         Resultado: Prueba

Scope and The Scope Chain
    Definition
        Scoping: How our program’s variables are organized and accessed.
            Scoping ask the questions: “Where do variables live?” or “Where can we access a certain variable, and where not?”
        Lexical scoping: Scoping is controlled by placement of functions and blocks in the code.
            Variables in child function can access to variables in father function
    --> Scope: Space or environment in which a certain variable is declared (variable environment in case of functions).
            There is global scope, function scope, and block scope.
            In the case of functions is the same the scope and the variable environment of execution context.
        Scope of a variable: Region of our code where a certain variable can be accessed.
    Types of scope
        Global scope
            Outside of any function or block
            Variables declared in global scope are accessible everywhere
            Example:
                const x = 1
                const y = 2
                const a = "nombre"
        Function scope
            Variables are accessible only inside function, NOT outside
            Also called local scope
            Example:
                function (){
                    const z = 1
                    h = z + 3
                    return h
                }
                console.log(z)          // Resultado: Error
        Block Scope (ES6)
            Variables are accessible only inside block (block scoped)
            HOWEVER, this only applies to let and const variables!
            Functions are also block scoped (only in strict mode)
            Example:
                if (x < 5 && y = 2){
                    const coord = 25
                    var valor = true
                }
                console.log(coord)      // Resultado: Error
                console.log(valor)      // Resultado: true
    The Scope chain
        Es una cadena de alcance de las variables.
        Variable lookup in scope chain
            JS look from child to parents scopes, not from the other way. 
            Childs can acces to parents variable but parents can't acces to child variables
        const myName = "Jose"
        function first (){
            const age = 30          // Global variable
            if (age >= 30) {const decade = 3; var millenial = true}
            function second (){const job = "teacher"; console.log (`${myName} is a ${age}-olg ${job}`)}
            second()
        }
        first()
        Variable myName scope chain = all
        Variable age scope chain = first(), IF, second() 
        Variable decade scope chain = IF
        Variable millenial scope chain = first(), IF, second()
        Variable job scope chain = second()
        Access scope chain variables second() = nyName, age, millenial, job
        Access scope chain variables IF = myName, age, millenial, decade
        Access scope chain variables first() = age, millenial, nyName
        Access scope chain variables global = nyName
    Differences between Scope chain vs Call Stack
        Call Stack
            Is the order of execution
            In our example:
                second
                IF
                first
                global
        Scope Chain
            Is the acces of variables
            Has nothing to do with order in which functions were called!

Variable environment: hoisting and the TDZ
    Definition
        Hoisting: Makes some types of variables accessible/usable in the code before they are actually declared.“Variables magical lifted to the top of their scope”.
                ^
            BEHIND THE SCENES
                ^
        Before execution, code is scanned for variable declarations, and for each variable, a new property is created in the variable environment object.
    How it works hoisting
                                                Hoisted?                    Initial value               Scope
        function declarations                   Yes                         Actual function             Block (In strict mode. Otherwise: function!)
                We can use function declarations before they are actually declared in the code, because they are stored in the variable environment object even before the code starts executing
        var variables                           Yes                         Undefined                   Function
                If we want use a var variable before declaration, the variable has a initial value of "undefined", not an error. Common bugs, this is why in modern JS we don't use "var"
        let/const variables                     No in practice              <uninitialized>,TDZ         Block
                                                but yes technically         Temporally Dead Zone
                We say that these variables are placed in the TDZ. Which makes it so that we can't access the variables between the beginning of the scope and the plce where the variables are declared. In this case we have an error, not undefined.
        function expressions and arrows                     Depends if use var or let/const
    Temporal Dead Zone, let and const
        Example:
            const nyName = "Jose"
            if (myName === "Jose"){
            (1) console.log(`Jose is a ${job}`)
            (2) const age = 2021 - 1990
            (3) console.log(age)
            (4) const job = "farmer"
            (5) console.log(x)
            }
        TDZ for job variable is: (1)(2)(3). The variable didn't even exist.
            TDZ starts at the beginning of the scope until the line where it is defined
        (1) ReferenceError: Cannot access "job" before initialization ----> We try to acces before we define it
        (5) ReferenceError: x is not defined ----> variable X not created. It is in TDZ until his value is declared
    Why was created TDZ?
        Makes it easier to avoid and catch errors: accesing variables before declaration is bad practice and should be avoided.
        Makes const variables actually work. Because we can't define to "undefined"(like var) and later reassign with other value
    Why exists hoisting?
        Using functions before actual declaration
        Var hoisting is just a byproduct.

This keyword
    Definition
        this keyword/variable: Special variable that is created for every execution context (every function).
        Takes the value of (points to) the “owner” of the function in which the this keyword is used.
        this is NOT static. It depends on how the function is called, and its value is only assigned when the function is actually called.
        this does NOT point to the function itself, and also NOT the its variable environment!
    Examples of this to analyze
        Method ---->                        this = <Object that is calling the method>
            const persona = {
                name : "Jose"
                year: 1990
                calcAge : function {            // calcAge is method
                    return 2021 - this.year     // this = persona (same result as persona.year)
                }
            }
        Simple function call ---->          this = undefined (in strict mode. Otherwise(in the browser): window)
            Not attached to any object.
        Arrow functions ---->               this = <this of surrounding function (lexical this keyword)>
            Don't get their own "this keyword". The this function of the parent function
        Event listener ---->                this = <DOM element that the handler is attached to>
        new,call,apply,bind ---->           <Later in the course...>

Regular functions vs Arrow functions
    NEVER EVER use arrow functions as a method (function in object). The problem is "This keyword". The arrow functions haven't "This keyword".
        const amarillo = {
            firstName2: 'Antonio',
            greet: () => console.log(`Hey ${this.firstName2}`),
            greet2: function () { console.log(`Hey ${this.firstName2}`); },
        };
        amarillo.greet();                   // "Hey undefined". Amarillo object isn't a scope (global, function or block)
        var firstName2 = 'Matilda';         // If we have this variable in global scope. The arrow function can lead to error
        amarillo.greet();                   // "Hey Matilda". This happen because "this.firstName2" belongs to window object, NOT to amarillo object
        amarillo.greet2();                  // "Hey Antonio". Normal functions have YES "This keyword"
    Regular function called. Inside a regular function call, "This keyword" must be undefined
        const amarillo = {
            year: 1990,
            calcAge: function () {
                const isMillenial = function () {
                    console.log(this);              //undefined
                    console.log(this.year >= 1981 && this.year <= 1996);
                };
                isMillenial();                      // Regular function call. Resultado: TypeError: Cannot read property 'year' of undefined
            },
        };
        amarillo.calcAge(); //TypeError: Cannot read property 'year' of undefined
    Regular function called. Solutions
        Use "self" or "that". Before ES6
            calcAgeSelf: function () {
                const self = this; const that = this    // We use "self" or "that" like as a reminder of "This keyword"
                const isMillenial = function () {
                    console.log(self);                  // Object amarillo
                    console.log(that);                  // Object amarillo
                    console.log(`Self or that: ${self.year >= 1981 && self.year <= 1996}`);
                    console.log(`Self or that: ${that.year >= 1981 && that.year <= 1996}`);
                };
                isMillenial();                      // Regular function call. Resultado: true
            },
            Resultado: Self or that: true
    --> Use Arrow function. After ES6
            calcAgeArrow: function () {
                const isMillenial = () => {
                    console.log(this);
                    console.log(
                        `Arrow function: ${this.year >= 1981 && this.year <= 1996}`
                    );
                };
                isMillenial(); // Regular function call
            },
            Resultado: Arrow function: true
    Arguments keyword. Not important in moderns JS, use other ways
        Only available in regular functions
            const addExpr3 = function (a, b) {
                console.log('Arguments keyword:');
                console.log(arguments);                     // arguments YES exists
                return a + b;
            };
            addExpr3(3, 4);                                 // console.log = Array with arguments [3, 4]
            var addArrow2 = (a, b) => {
                console.log('Arguments keyword arrow:');
                console.log(arguments);                     // Not exists in arror functions
                return a + b;
            };
            addArrow2(3, 4);                                // Arguments is not defined

Primitives vs objects (primitive vs reference types)
    Primitives are stored in CALL STACK
        Primitive types: number, string, boolean, undefined, null, symbol, BigInt.
    Objects are stored in HEAP.
        Because objects might be too larg to be stored in the call stack, instead they are stored in the heap wich is like an almost unlimited memory pool
        Reference types: object literal, arrays, functions, etc
    Example:
        Primitives
            let age = 30;
            let oldAge = age;
            age = 31;
            console.log(age);                   // Resultado: 31
            console.log(oldAge);                // Resultado: 30
        Objects 
            const me = {
                name: 'Jose',
                age: 30,
            };
            const friend = me;
            friend.age = 27;
            console.log('Friend: ', friend);    // Resultado: 27
            console.log('Me: ', me);           // Resultado: 27            Here we see how we can change CONST value
    This happen because primitives are stored in differents memories and the object point into the same memory
        Primitives
            NAME            MEMORY          VALUE ADRESS
            Age             Memory 001      30 ==> 31
            oldAge          Memory 002      31
            So, when we change the value of Age, we change the value of Memory 001, but the Memory 002 not change
            Memory 001 -- Memory adress --> 30 ==> 31
            Memory 002 -- Memory adress --> 31
        Objects (Reference value)
            me ----> Memory 003 (30 ==> 27) <---- friend
            So, when we change the value of friend object, we change the value of Memory 003, wich is pointed by the 2 objects
            Memory 003 -- Memory adress --> D30F
    How to copy a new object and no modify the old object
        const NAME = Object.assign ( {} , OBJECT )
        const friend2 = Object.assign ( {} , me )
        Example:
            friend2.age = 27
            console.log(friend2.age)        // Resultado: 27
            console.log(me.age)             // Resultado: 30
        But only work in the first level. If we have a object inside an object, this way don't work.
            Both objects point to the same second level object
            To do a "deep clone" we use an externals libraries like "Lo-Dash"

3 more big topics of how JS works behind the scenes (for later..)
    Prototypal Inheritance:         Object Oriented Programming (OOP) With JavaScript               in Section 14
    Event Loop:                     Asynchronous JavaScript: Promises, Async/Await and AJAX         in Section 16
    How the DOM Really Works:       Advanced DOM and Events                                         in Section 13


---------------------- DATA STRUCTURES, MODERN OPERATORS AND STRINGS ----------------------

Destructuring arrays
    Destructuring is an ESx feature and it's basically a way of unpacking values from an array or an object into separate variables
    Creating arrays
        const array = []
    Types of assign variables to array value
        const arr = [2, 3, 4, 5, 6, 7, 8];
        First type
            let a = arr[0];           // a = 2
            let b = arr[1];           // b = 3
            let c = arr[4];           // c = 6
        Second type
            let [x, y, , , z] = arr;      //x = 2; y = 3; z = 6
    Reassign / mutating (Example: change value between a and b)
        First
            const temp = a          // temp = 2
            a = b                   // a = 3
            b = temp                // b = 2
        Second
            [a, b] = [b, a];        // a = 3; b = 2
    Receive 2 return values from a function
        const restaurant = {
            starterMenu: ['Focaccia', 'Bruschetta', 'Garlic Bread', 'Caprese Salad'],
            mainMenu: ['Pizza', 'Pasta', 'Risotto'],
            order: function (starterIndex, mainIndex) {
                return [this.starterMenu[starterIndex], this.mainMenu[mainIndex]];
            },
        };
        const [starter, mainCourse] = restaurant.order(2, 0);               // starter = "Garlic Bread"; mainCourse = "Pizza"
    Nested: one array inside another array
        const nested = [2, 4, [5, 6]];
        const [i, , j] = nested                         // i = 2; j = [5,6]
        const [i, , [j, k]] = nested;                   // i = 2; j = 5; k = 6
    Default values. For example, when we don't know how long in an array
        const [p, q, r] = [8,9]             // p = 8; q = 9; r = undefined
        const [p=1, q=1, r=1] = [8, 9]      // p = 8; q = 9; r = 1

Destructuring objects
    Creating objects
        const object = {}
        const {object1, object2, object3} = {direccion1, direccion2, direccion3}
    Example
        const restaurant = {
            name: 'Classico Italiano',
            location: 'Via Angelo Tavanti 23, Firenze, Italy',
            categories: ['Italian', 'Pizzeria', 'Vegetarian', 'Organic'],
            starterMenu: ['Focaccia', 'Bruschetta', 'Garlic Bread', 'Caprese Salad'],
            mainMenu: ['Pizza', 'Pasta', 'Risotto'],
            openingHours: {
                thu: {
                    open: 12,
                    close: 22,
                },
                fri: {
                    open: 11,
                    close: 23,
                },
                sat: {
                    open: 0, // Open 24 hours
                    close: 24,
                },
            },
        };
    Creating new objects with the same name than the propierties
        const {name, openingHours, categories} = restaurant             // They are the same
    Creating new objects with different name than the propierties
        const { name: restaurantName, openingHours: hours, categories: tags} = restaurant;
        console.log(restaurantName, hours, tags);                       // Same
    Default values. When the propierty don't exist
        const { menu, starterMenu: starters} = restaurant;              // menu = undefined
        const { menu = [], starterMenu: starters = [] } = restaurant;   // If the property don't exist, the object = [empty array]
    Mutating
        It is different from array, we need to put () outside {} because JS when see {} expects complex code
            let a = 111;
            let b = 999;
            const obj = { a: 23, b: 7, c: 14 };
            ({ a, b } = obj);                       // a = 23; b = 7
    Nested(objects inside objects). Example: openingHours inside restaurant
        const { fri } = openingHours;               // Resultado: { open: 11, close: 23}
        const {
            fri: { open, close },
        } = openingHours;
        console.log(open, close)                    // Resultado: 11 23
        const {
            fri: { open: o, close: n },
        } = openingHours;
        console.log(o, n);                          // Resultado: 11 23
    Automatic destructuring
        const restaurant = {
            ...
            orderDelivery: function ({ starterIndex, mainIndex, time, address }) {
                    console.log(
                        `Order received! ${this.starterMenu[starterIndex]} and ${this.mainMenu[mainIndex]} will be delivered to ${address} at ${time}`
                    );
                },
            ...
        }
        restaurant.orderDelivery({
            time: '22:30',
            address: 'Calle Falsa, 234',
            mainIndex: 2,
            starterIndex: 2,
        });                                     Resultado: Order received! Garlic Bread and Risotto will be delivered to Calle Falsa, 234 at 22:30

The spread operator "..."
    Used to expand an array into all its elements, so basically unpacking all the array elements at one
    Structure
        const arr2 = [7, 8, 9];
        const badNewArr = [1, 2, arr2[0], arr2[1], arr2[2]];        // Or use FOR loop. Resultado: badNewArr = [1,2,7,8,9]
        const NewGoodArray = [1, 2, ...arr2];                       // Resultado: NewGoodArray = [1,2,7,8,9]
    It is used to expand arrays (like example before) or when we pass arguments into functions
    Expand array individually
        console.log(...NewGoodArray);       // 1 2 7 8 9 // Number by number
    Shadow copies of arrays (Similar to object.assign() but more easier to use)
        const mainMenuCopy = [...restaurant.mainMenu]
    Merge two arrays together
        const menuMerge = [...restaurant.mainMenu, ...restaurant.starterMenu];
    The spread operator works on all so-called iterables
        Iterables: things like all arraysm strings, maps or sets and objects (since ES2018 although objects are not iterables)
        Strings
            const str = 'Jose';
            const letters = [...str];       // Resultado: letters ["J", "o", "s", "e"]
    Multiple values separated by a comma are usually only expected when we pass arguments into a function
        console.log (...str)                // Resultado: J o s e
        console.log(`${...str} Antonio`)    // Error
    Method to spread operator example
        const restaurant = {
            ...
            orderPasta: function (ing1, ing2, ing3) {
                console.log(
                    `Here is your delicious pasta with ${ing1}, ${ing2} and ${ing3}`
                );
            },
        };
        const ingredients = ['Champiñones', 'Aceitunas negras', 'Tomate', 'Pepinillos'];
        restaurant.orderPasta(...ingredients);              // Resultado: Here is your delicious pasta with Champiñones, Aceitunas negras and Tomate
    Since ES2018 spread operator actually also work on objects(objects are not iterables)
        const newRestaurant = { founderYear: 1985, ...restaurant, founder: 'Guiseppe' };
        Shadow copies
            const restaurantCopy = {...restaurant}
            In this case we can change values and not affect to the first object. The 2 objects NOT point to the same memory
            Previous
                const restaurante2 = restaurant
                restaurante2.name = "Restaurante Bonito"
                console.log(restaurante2.name)              // Resultado: Restaurante Bonito
                console.log(restaurant.name)                // Resultado: Restaurante Bonito
                restaurant ----> Memory 001 <---- restaurante2
            Now
                const restaurante2 = {...restaurant}
                restaurante2.name = "Restaurante Bonito"
                console.log(restaurante2.name)              // Resultado: Restaurante Bonito
                console.log(restaurant.name)                // Resultado: Classico Italiano
                restaurant ---->    Memory 001
                restaurante2 ---->  Memory 002
        Merge
            const restaurantDelivery = {
                name: "Restaurant deliveroo"                // In this case overwrite this property, because is the second merging
                address: 'Calle falsa, 123',
                phone: '555 666 777',
                doors: 3,
            };
            const restaurantmerge = { ...restaurant, ...restaurantDelivery };
            console.log(restaurantmerge);

Rest pattern and parameters
    Exactly like spread operator but Rest Pattern works than spread operator. Rest Pattern works to collect multiple elements and condense them into an array
    Spread is used in right side of =
        const spread = [1, 2, ...arr]                                       // spread = [1, 2, 7, 8, 9]
    Rest is used in LEFT side of =
        const [a, b, ...others] = [1, 2, 3, 4, 5]                           // a = 1; b = 2; others = [3, 4, 5]
        const [a, b, others] = [1, 2, 3, 4, 5];                             // a = 1; b = 2; others = 3
    We can't use in the middle
        const [a, b, ...others, c] = [1, 2, 3, 4, 5]                        // Error
    It works in Objects. It will be collected into a new object and not into a new array
        const { sat, ...weekDays } = restaurant.openingHours;               // sat = {...}; weekDays ={thu:{...}, fri:{...}}
        console.log(sat, weekDays);
    Example of use:
        const add = function (...numbers) {                     
            let sum = 0;
            for (let i = 0; i < numbers.length; i++) {
                sum += numbers[i];
            }
            console.log(sum);
        };
        add(2, 3);                              // Resultado: 5
        add(5, 3, 7, 2);                        // Resultado: 17
        add(8, 2, 5, 3, 2, 1, 4);               // Resultado: 25
        const arrayParameter = [23, 5, 7];
        add(...arrayParameter);                 // Resultado: 35
    We write "...numbers" in parameters because the function accept arrays [add(...arrayParameter)] and simply numbers [add(5, 3, 7, 2);]

Short circuiting (&& and ||)
    We can use AND and OR operators more than boolean values
    OR operator
        return the first true value.
    AND operator
        return the last true value. If all are true
        returnt the first false value if at least one is false
    OR popierties
        They can use any data type
            console.log (3 || "Jonas")
        Return any data type
            Resultado: 3
        Short-ciruiting, also called short circuit evaluation
            If the first value is TRUE, the other will not even be evaluated(JS will not even take a look at it)
            Evaluate everything and return the first value
    AND popierties
        They can use any data type
            console.log (3 && "Jonas")
        Return any data type
            Resultado: Jonas
        Short-ciruiting, also called short circuit evaluation
            If the first value is FALSE, the other will not even be evaluated(JS will not even take a look at it)
            Evaluate everything and return the last value

The nullish coalescing operator ( ?? )
    Introduced in ES2020
    Work with the idea with NULLISH values instead of FALSE values    
    Nullish values
        null
        undefined
        (NOT 0 or "")

Looping arrays: the FOR-OF loop
    Structure
        for (const NAME of ITERABLE) {
            CODING
        }
    Example
        const menuFor = [...restaurant.starterMenu, ...restaurant.mainMenu];
        for (const item of menuFor) {
            console.log(item);              // Resultado(individually): Focaccia, Bruschetta, Garlic Bread, Caprese Salad, Pizza, Pasta, Risotto.
        }
        Same as before but much more simple
        for (let i = 0; i < menuFor.length; i++) {
            console.log(`${menuFor[i]}`);
        }
    Still working "Continue" and "break" keywords

Enhanced object literals
    Object oustide an object. Not necesary to repeat variable name and object
        const Horas = { lunes: { ... }, viernes: { ... }, Dia-6: { ... }, };
        const Restaurante = {
            name: 'Restaurante italiano',
            // Before ES6
            //Horas: Horas,
            // After ES6
            Horas,
        };
    Writing methods
        const Restaurante = {
            // Before ES6
            order: function (param1, param2) { console.log('Order 1'); },
            // After ES6
            order2(param1, param2) { console.log('Order2'); },
        };
    We can compute(calculate) names instead of having to write out manually and literally
        const dias = ["lun","mar","mier","Jue","vie","sab","dom]
        const Horas = { [dias[0]]: { ... }, [dias[4]]: { ... }, [`Dia-${2+4}`: { ... }, };

Optional Chaining ( ?. )
    If a certain property does NOT exist, then undefined is returned inmetiately
    Structure
        console.log(restaurant.openingHours.mon?.open);
        If exists "mon", then show "open". But if not exists "mon", then undefined is show
    Multiple Optional Chaining
        console.log(restaurant.openingHours?.mon?.open);
    Use in methods
        console.log(restaurant.order?.(0, 1) ?? 'Method does not exist');
    Use in arrays
        const users = [{ name: 'Antonio', email: 'emailfalso@falso.com' }];
        console.log(users[0]?.name);                    // Resultado: "Antonio"

Looping objects: Object keys, values and entries
    Meaning
        Property names = keys
        Value = values
        Entries = keys + values on objects. On arrays, index number + element
    Looping keys
        for (const day of Object.keys(openingHours)) {
            console.log(day);               // Show us the name of the propierties=keys of the key "openingHours"
        }
        for (const names of Object.keys(restaurant)) {
            console.log(names);             // Show us the name of the propierties=keys of the object restaurant
        }
    Looping values
        for (const value of Object.values(categories)) {
            console.log(`Category of ${value} food`);
        }                                   // Show only the values
    Looping entries
        for (const entrada of Object.entries(openingHours)) {
            console.log(`We open at ${entrada[1].open}`);
            console.log(entrada)
        }                                   // Show entrada[0] = "thu"; entrada [1] = {open:12 ,close:22}
        const entrada = Object.entries(openingHours);
        for (const [key, { open, close }] of entrada) {
            console.log(`On ${key} we open at ${open} and close at ${close}`);
        }                                   // Resultado: On thu we open at 12 and close at 22

Sets
    It's a collection of unique values. NO duplicates. The order of the elements no matter
    Not replace arrays at all
    Main use case of sets is actually to remove duplicate values of arrays
    Creation
        const NAME = new Set([USUALLY AN ARRAY])
        const ordersSet = new Set(['pasta', 'pizza', 'pizza', 'Risotto', 'pasta', 'Pizza']);
        orders = ['pasta', 'pizza', 'pizza', 'Risotto', 'pasta', 'Pizza']
        const ordersSet = new Set(orders);
        console.log(ordersSet)                      // Resultado: Pasta, pizza, Risotto, Pizza      // Just only these
    Size NOT length
        console.log(ordersSet.size)                 // Resultado: 4
    Check if an element is in the set
        console.log(ordersSet.has("Pizza"));        // Resultado: true
    Add new elements
        ordersSet.add("Garlic Bread")
    Delete elements. Delete ALL copies
        ordersSet.delete("pizza")                   // Resultado: Pasta, Risotto, Pizza, Garlic Bread
    Delete ALL elements
        ordersSet.clear()
    Retrieve values
        There is NO WAY of getting values out of a set
        But, we can transform the set into an array
            const ordersSetArray = [...new Set(orders)]
        And in this case we can retrieve the values without duplicates
    Looping
        for (const order of ordersSet) {
            console.log(order);
        }

Maps: fundamentals
    It is the same than the objects but in objects the keys are always strings and in maps the keys can be any type(objects, array, other maps)
    Creation
        const NAME = new Map()
        const restMap = new Map()
        The normal thing is to create it empty and later add
    Add elements
        restMap.set("KEY", "VAUE").set("KEY2", "VALUE2")
        restMap.set('name', 'Classico Italiano');
        restMap.set(1, 'Lisboa').set(2, "Portugal");
        restMap.set('categories', ['Italian', 'Pizzeria', 'Vegetarian', 'Organic']);
        restMap.set(document.querySelector('h1'), 'Heading');
    Read data
        restMap.get(1);                 // Resultado: Lisboa
    To know if a key exists
        restMap.has('categories');      // Resultado: true
    Delete elements
        restMap.delete(2)
    Delete ALL elements
        restMap.clear()
    Size
        console.log(restMap.size);
    Keys with arrays
        restMap.set([5, 6], 'Test');
        console.log(restMap.get([5, 6]));       // Resultado: undefined. Because not refered to the same place in memory
        const arrMap = [5, 6];
        restMap.set(arrMap, 'Test');
        console.log(restMap.get(arrMap));       // Resultado: Test. Because arrMap refered to the same place in memory pointing the array value
    Add elements without using set
        const question = new Map([
            ['question', 'What is the best programming language?'],
            [1, 'C'],
            [2, 'Java'],
            [3, 'JavaScript'],
            ['correct', 3],
            [true, 'Correct!'],
            [false, 'Try again!'],
        ]);
    It exists an easy way to convert from objects to maps
        const MAP = new Map(Object.entries(OBJECT));
        const hourMap = new Map(Object.entries(openingHours));
    Convert a map into an array
        const mapToArray = [...question];
    Entries, keys and values work
        question.entries()
        question.keys()
        question.values()

Which data structure to use?
    Sources of data
        From the program itself: Data written directly in source code (e.g. status messages)
        From the UI: Data input from the user or data written in DOM (e.g tasks in todo app)
        From external sources: Data fetched for example from web API (e.g. recipe objects)
    With all data of the sources we'll create Collection of Data.
    This Collecions of Data has Different types of Data Structure.
    Data Structure
        Simple list?
            Array
            Set
        Key/Value pairs? Keys allow us to describe the values
            Object
            Map
    Other built-in
        In JS: WeakMap, WeakSet
        Not in JS : stacks, queues, linked lists, trees, hash tables
    Differences
        Simple list
            Arrays
                Use when you need ordered list of values (might contain duplicates)
                Use when you need to manipulate data
            Sets
                Use when you need to work with unique values
                Use when high-performance is really important
                Use to remove duplicates from arrays
        Key/Value pairs
            Objects
                More “traditional” key/value store (“abused” objects)
                Easier to write and access values with . and []
                Use when you need to include functions (methods)
                Use when working with JSON (can convert to map)
            Maps
                Better performance
                Keys can have any data type
                Easy to iterate
                Easy to compute size
                Use when you simply need to map key to values
                Use when you need keys that are not strings

Working with Strings - Part 1
    Boxing
        When we call a method in a string, JS automatically transform the string in a object with the same content.
        It's on that object where the methods are called.
        new String("Jose")                  // Resultado: { 0:"J",1:"o",2:"s",3:"e",}
    Methods very used
            const airline = 'TAP Air Portugal';
            const plane = 'A320';
        Consult position
            plane[0];                       // Resultado: A
            'B737'[1];                      // Resultado: 7 (string)
        Lenght
            airline.length;                 // Resultado: 16
            'Prueba de lenght'.length;      // Resultado: 16
        Position of letter or word
            airline.indexOf('r');           // Resultado: 6
            airline.lastIndexOf('r');       // Resultado: 10
            airline.indexOf('Portugal');    // Resultado: 8
            airline.indexOf('portugal');    // Resultado: -1 (not found)
        Position start and stop. Last value is not included
            airline.slice(4);               // Resultado: Air Portugal
            airline.slice(4, 9);            // Resultado: Air P
            airline.slice(-4);              // Resultado: ugal
            airline.slice(6, -1);           // Resultado: r Portuga
            airline.slice(0, airline.indexOf(' '));         // Resultado: TAP
            airline.slice(airline.lastIndexOf(' ') + 1);    // Resultado: Portugal

Working with Strings - Part 2
    Uppercase
        "HOLA QUE TAL".toLowerCase()       // Resultado: tap air portugal
    Lowercase
        airline.toUpperCase()       // Resultado: TAP AIR PORTUGAL
    Removes whitespace from both sides
        const Email = '  Hello@Jose.iO \n';
        const trimedEmail = loweEmail.trim();           // Resultado: Hello@Jose.iO
    We can put methods one followed by another
        const normalizedEmail = loginEmail.toLowerCase().trim();
    Replace parts of strings
        const priceGB = '288,97 Pounds';
        const priceUS = priceGB.replace('Pounds', 'Dollars').replace(',', '.');         // Resultado: 288.97 Dollars
        const announcement = 'All passengers come to boarding door 23. Boarding door 23!';
        announcement.replace('door', 'GATE')    // Resultado: All passengers come to boarding GATE 23. Boarding door 23!
        announcement.replaceAll('door', 'GATE') // Resultado: All passengers come to boarding GATE 23. Boarding GATE 23!
    Return booleans
        const plane = "Airbus A320neo"
        plane.includes('A32')           // Resultado: true
        plane.startsWith('Air')         // Resultado: true
        plane.endsWith('eo')            //Resultado: true

Working with Strings - Part 3
    Separating strings
        'A very niceD string'.split(' ')        // Resultado: ["A", "very", "niceD", "string"]
    Uniting strings
        const name = ['Mr.', firstName, lastName.toUpperCase()]
        const newName = name.join(' ');         // Resultado: Mr. Jose GONZALEZ
    Padding strings
        Add a number of characters to the string until the string has a certain desired lenght
        message.padStart(25, '+');              // Resultado: +++++++++++Go to gate 23!
        message.padEnd(24, '-');                // Resultado: Go to gate 23!----------
        const last = message.slice(-4).padStart(message.length, '*');
    Repeat
        message.repeat(3)                       // Resultado: Go to gate 23!Go to gate 23!Go to gate 23!


---------------------- A CLOSER LOOK AT FUNCTIONS ----------------------

Default parameters
    Example
        const createBooking = function (flightNum="0001", numPassengers = 1, price = 199 * numPassengers ) {
            // Default value ES5:
            flightNum = flightNum || "0001"
            numPassengers = numPassengers || 1;
            price = price || 199;
        };
    Calling functions by defaults parameters
        createBooking()                             // Resultado: 0001, 1, 199
        createBooking("H123", undefined, 500)       // Resultado: H123, 1, 500

How passing arguments works: value vs reference
    Primitives
        JS copy the value, not change the original
            let flightNum = 100
            function (flightNum){flightNum = 3}     // Resultado: 3
            console.log(flightNum)                  // Resultado: 100
    References
        JS no copy the reference, if something change, the reference will change. So all what pointing the reference will change
            let jonas = {name:"Jonas", pass:"123"}
            function (name){jonas.name = "Pedro"}     // Resultado: Pedro
            console.log(jonas)                  // Resultado: Pedro
    JS does NOT have passing by reference, ONLY passing by value

First-Class and higher-Order Functions
    First-class functions
        JS trats functions as first-class citizen, this means that functions are simply values
        Functions are just another "type" of object
        Store functions in variables or propierties
            const add = (a,b) => a + b                                      // (a,b) => a + b
            const counter = {value: 23, inc: function(){this.value++}}      // function(){ this.value++ }
        Pass functions as arguments to OTHER functions
            btnClose.addEventListener("click", add )                        // add
        Return functions FROM functions
        Call methods on functions
            counter.inc.bind(someOtherObject)                               // "bind()"
    Higher-order functions
        A function that receives another function as an argument, that returns a new function, or both
        This is only possible because of first-class functions
        Function that receives another function
            btnClose.addEventListener("click", add )                        // addEventListener (High-Order); add (Callback function)
        Function that returns new function
            function count(){                                               // count (High-Order)
                let counter = 0
                return function () { counter ++}                            // function() (returned function)
            }
    There are NO first class functions in practice, it's just a concept.
    There are higher order functions in practice, wich are posible because JS supports first class functions
    Abstraction
        We hide the detail of some code implementation because we don't really care about all that detail

The call and apply methods
    Example
        const lufthansa = {
            book(flightNum, name) {
                console.log( `${name} booked a seat on ${this.airline} flight ${this.iataCode}${flightNum}`
        );},};
        const book = lufthansa.book;
        const eurowing = {
            airline: 'Eurowings',
            iataCode: 'EW',
            bookings: [],
        };
        book(23, 'Pepito'); // Resultado: Error. Because "this keyword NOT point to nothing --> undefined"
    We need to say JS explicity what the "this keyword" should be with
    Call
        NAME.call(THISKEYWORD, OTHERPARAMETERS)
        book.call(eurowing, 23, 'Sarah');               // Resultado: Sarah booked a seat on Eurowings flight EW23
        book.call(lufthansa, 213, 'Cooper');
        Is necesary that the propierties HAVE the same name because "this keyword" look there "this.iataCode"
    Apply.
        It is the same than call, but use an array in parameters
        NAME.apply(THISKEYWORD, [OTHERPARAMETERS])
        book.apply(lufthansa, [968, 'Pepito']);
        const flightData = [854, 'John Cooper'];
        book.apply(lufthansa, flightData);                  // Resultado: John Cooper booked a seat on Lufthansa flight LH854
        NOT USED in modern JS, CALL method is the same:
            book.call(lufthansa, ...flightData);            // Resultado: John Cooper booked a seat on Lufthansa flight LH854
    Bind
        Studied in detail in next section

The bind method
    Manually sets the "this keyword" for any function call
    Bind does NOT immediately call the function, instead it returns a new function where the "this keyword" is bound. So it's set to whatever value we pass into bind
    Structure
        book.bind(eurowing)         // This NOT call the function, returns a new function so we can save in a variable
        const bookEW = book.bind(eurowing);
    Calling the bind method
        bookEW(125, 'Steven');      // Resultado: Steven booked a seat on Eurowings flight EW125
    It is possible to use a default parameter when use bind method
        const bookEW23 = book.bind(eurowing, 23)        // The first parameter is 23 and we use this method, allways will be 23
        bookEW23('Pedrito');        // Resultado: Pedrito booked a seat on Eurowings flight EW23
    Using with event listeners
        .querySelector('.buy').addEventListener('click', lufthansa.buyPlane.bind(lufthansa))      // We force to point to lufthansa object. Not to the class "buy"
        .querySelector('.buy').addEventListener('click', lufthansa.buyPlane))      // NOT working because "this keyword" is pointing to "buy" class
    Partial application
        When we are not interested in "this keyword" but we still use bind method for something like default parameters
            const addTax = (rate, value) => value + value * rate;
            console.log(addTax(0.1, 200));
            const addTaxIVA = addTax.bind(null, 0.21); // const addTaxIVA = value => value + value * 0.21;
            console.log(addTaxIVA(100));
        We can use default parameters but this here is creating a brand new simply more specific function based on a more general function.
        It permit to create a much more default parameters
            const IVAGeneral = addTax.bind(null, 0.21);
            const IVAReducido = addTax.bind(null, 0.1);
            const IVASuperReducido = addTax.bind(null, 0.04);

Immediately invoked function expressions ( IIFE )
    If we want to use one function once and never more we can do it
        ( function(){console.log('This will never run again')} ) ();
        const runNotOnce=function(){console.log('This function will run again')};
    Arrow functions IIFE
        ( ()=>console.log('This will ALSO never run again') ) ();
    In modern JS, IIFE are NOT that used anymore to maintain private variables
        Because if all we want is to create a new scope for data privacy. All we need to do is to just create a block like
            {
                const isPrivate = 25;
                var notPrivate = 35;
            }
        There's no need to creating a function to create a new scope. Unless we use var
    In modern JS, if you need to execute a function just once, then the IIFE is still the way to go

Closures
    Is not a feature that we explicitly use. SO, we don't create closures.
    Closures just simply happen automatically in certain situations. We need recognice those situations.
    Any function always has access to the variable environment of the execution context in which the function was created.
        Even after a debt execution context is gone.
    Closure: variable environment attached to the function, exactly as it was at the time and place the function was created.
 -> A closure is like a backpack that a function carries around wherever it goes.
        This backpack has all the variables that were present in the environment where the function was created.
            Person      ---->   Function
            Backpack    ---->   Closure
            Books       ---->   Variables
    We do NOT have to manually create closures, this is a JavaScript feature that happens automatically
        We can’t even access closed-over variables explicitly. A closure is NOT a tangible JavaScript object.
    To see the closure
        console.dir(FUCTION)    ==>     [[Scopes]]  ==>     0: Closure


---------------------- WORKING WITH ARRAYS ----------------------

Simple array methods
    Slice method
        We can extract part of any array, but without changing the original array. Similar to the string.
        arr = ['a', 'b', 'c', 'd', 'e']
        arr.slice(1,4)                  // Resultado: ["b", "c", "d"]
        NOT included the last
        arr.slice(2)                    // Resultado: ["c", "d", "e"]
        arr.slice(-2)                   // Resultado: ["d", "e"]
        We can create a shadow copy
        const arrCopy = arr.slice()     // Resultado: ['a', 'b', 'c', 'd', 'e']
        const arrCopy = [...arr]        // Resultado: ['a', 'b', 'c', 'd', 'e']
    Splice method
        It is similar than Slice but Splice YES change the original array
            const arrSlice = ['a', 'b', 'c', 'd', 'e', 'f', 'g'];
            arrSlice                    // Resultado: ['a', 'b', 'c', 'd', 'e', 'f', 'g'];
            arrSlice.splice(2, 4))      // Resultado: ["c", "d", "e", "f"]
            arrSlice                    // Resultado: ["a", "b", "g"]
        In this case, the second value is included
            splice(2,4) Included the values 2,3 and 4
            slice(2,4)  Included the values 2 and 3
    Reverse method
        This method turns it around the values
            const arrReverse = ['a', 'b', 'c', 'd', 'e', 'f', 'g'];
            arrReverse.reverse()        // Resultado: ["g", "f", "e", "d", "c", "b", "a"]
        Change the original value
            arrReverse                  // Resultado: ["g", "f", "e", "d", "c", "b", "a"]
    Concat method
        Use to concatenate two arrays
            const arrConcat = arr.concat(arrReverse);       // Resultado: ["a", "b", "c", "d", "e", "g", "f", "e", "d", "c", "b", "a"]
    Join method
        Unite the values in the array with a definive separation
            arr.join(' - ')             // Resultado: a - b - c - d - e
            arr.join(';')               // Resultado: a;b;c;d;e
            arr.join(' / next:')        // Resultado: a / next:b / next:c / next:d / next:e
    And much more

Looping arrays: forEach
    Same functioning than FOR-OF loop
    Structure
        ARRAY.forEach( function(element){} )
    Destructuring
        FOR-OF Loop
            for (const [i, movement] of movements2.entries()) {
                if (movement > 0) {
                    console.log(`Movement ${i + 1}: You deposited ${movement}`);
                } else {
                    console.log(`Movement ${i + 1}: You withdrew ${Math.abs(movement)}`);
                }
            }
        forEach
            movements2.forEach(function (movement, index, array) {          // ( CurrentElement, CurrentIndex, EntireArray )
                if (movement > 0) {
                    console.log(`Movement ${i + 1}: You deposited ${movement}`);
                } else {
                    console.log(`Movement ${i + 1}: You withdrew ${Math.abs(movement)}`);
                }
            });
    Using
        Is better using always forEach, instead:
        It not possible to break or continue the forEach method
    Maps
        MAP.forEach(function(VALUE, KEY, map) {})
    Sets
        SET.forEach(function(VALUE, KEY, set) {})
        In sets KEY = VALUE because sets does NOT have keys or indexes. For this, in real live use:
        SET.forEach(function(VALUE, _, set) {})
        Where "_" means a throwaway variable

Creating DOM elements
    Insert code in the HTML
        document.querySelector('').insertAdjacentHTML(POSITIONtoATTACHinHTML, TEXT)
            Position to attach in HTML
                'beforebegin': Before current element. Out of the element.
                'afterend': After current element. Out of the element.
                'afterbegin': Inside current element, after his first child element
                    array = [1, 2, 3, 4]
                    Order added: 4, 3, 2, 1
                'beforeend': Inside current element, before his last child element
                    Order added: 1, 2, 3, 4
        document.querySelector('.main').insertAdjacentHTML(afterbegin, "Prueba")

Data transformations: map, filter, reduce
    Big array methods used all the time to perform data transformations. Create new arrays.
        [3, 1, 4, 3, 2]
    Map method
        Returns a new array containing the results of applying an operation on all original array elements.
        MAP ----> current * 2 ----> [6, 2, 8, 6, 2]
        Better than forEach method
    Filter method
        Returns a new array containing the array elements that passed a specified test condition.
        FILTER  ----> current > 2 ----> [3, 4, 3]
    Reduce method
        Boils(“reduces”) all array elements down to one single value (e.g. adding all elements together)
        Reduce ----> accumulator + current  ----> [13]

The Map method
    Structure
        const NEWARRAY = ARRAY.map ( function((VALUE, INDEX, ARRAY)){ return OPERATION } )
        const movementsUSD = movements.map(function (mov) { return mov * eurToUSD; });
    We obtain the same results using FOR-OF loop but in modern JS is better to use map method
 -> Better using Arrow functions
    The princial diferente between Map Method and forEach method is:
        Map create a new array
        forEach not create a new array, just do things same as a loop

The Filter method
    Structure
        const NEWARRAY = ARRAY.filter ( (VALUE, INDEX, ARRAY) => OPERATION )
        const deposits = movements.filter(mov => mov > 0);
    We obtain the same results using FOR-OF loop but in modern JS is better to use filter method
 -> Better using Arrow functions

The Reduce method ( VERY IMPORTANT )
    Structure
        const NEWARRAY = ARRAY.reduce ( ((ACUMULATOR, VALUE, INDEX, ARRAY) => OPERATION), INITIALVALUEACCUM )
            ACUMULATOR
                Like a snowball that keeps accumulating the value that we ultimately want to return
        const balance = movements.reduce((acc, curr) => acc + curr, 0);
    Good use of array parameter: average
        const balance = movements.reduce( (acc, curr, i, arr) => acc + curr/arr.lenght, 0);
        ( 2+3 ) /2 == 2/2 + 3/2

The magic of chaining methods
    Pipeline
        It is posible to concatenate all the previous data transformations 
        const totalDepositsUSD = movements
            .filter(mov => mov > 0)
            .map(mov => mov * eurToUSD)
            .reduce((acc, mov) => acc + mov, 0);
    If we need to debugg we can use the console and the parameter array
        const totalDepositsUSD = movements
            .filter(mov => mov < 0)
            .map((mov, i, arr) => {
                console.log(arr); // Here we can see the bug: negative values
                return mov * eurToUSD;
            })
            .reduce((acc, mov) => acc + mov, 0);
    Chaining
        We should NOT overuse chaining. If use a lot of methods one below other, that will have problems.
        Think well what use, because two map methods can be translate into only one map method.
        NOT chain methods that mutate the original array

The find Method
    Retrieve ONE ELEMENT of an array based on a condition
    Structure
        const FIRSTELEMENT = ARRAY.find ( (VALUE, INDEX, ARRAY) => OPERATION )
        const encontrar = movements.find(mov => mov < 0);
    Differences between FIND and FILTER
        Find method stop when the first element fulfill the condition, while filter travel around all the array.
        Find method return ONE element and NOT an array. Filter method return an array

The findIndex Method
    Works as same as find method, but findIndex returns the index of the found element
    Structure
        const FIRSTINDEX = ARRAY.findIndex ( (VALUE, INDEX, ARRAY) => OPERATION )
        const encontrarIndex = movements.findIndex(mov => mov < 0);
    Work very good with "splice method", because we find the index and later we can delete it

Some and Every Method
    Some method
        Structure
            const BOOLEAN = ARRAY.some ( (VALUE, INDEX, ARRAY) => OPERATION )
            movements.some(mov => mov > 0)
        Similar to "includes"(Also bring back a boolean) but this method can't admit functions, only equality and "Some Method" admit functions, or conditions
            movements.includes(-130)
            movements.some( mov => mov == -130)
    Every method
        Structure
            const BOOLEAN = ARRAY.every ( (VALUE, INDEX, ARRAY) => OPERATION )
            movements.some(mov => mov < 5000)
        Similar to some, instead of only returns true if ALL elements satisfy the condition

Flat and FlatMap Method
    Flat
        It is used when we haven an array of arrays and whe want only one array without arrays inside
         Normally we use "Map method" and later "Flat method"
        Structure
            ARRAY.flat()
        Example 1
            const arrFlat = [ [1, 2, 3] , [4, 5, 6] , 7, 8];
            arrFlat.flat()                                      // Resutado: [1, 2, 3, 4, 5, 6, 7, 8]
        Example 2
            const arrFlatDeep = [ [ [1, 2] , 3] , [4, [5, 6] ] , 7, 8];
            arrFlatDeep.flat()                                  // Resutado: [Array(2), 3, 4, Array(2), 7, 8]
            arrFlatDeep.flat(1)                                 // Resutado: [Array(2), 3, 4, Array(2), 7, 8]
            arrFlatDeep.flat(2)                                 //Resultado: [1, 2, 3, 4, 5, 6, 7, 8]
            arrFlatDeep.flat(5)                                 //Resultado: [1, 2, 3, 4, 5, 6, 7, 8]
    FlatMap
        Introduced in ES2019
        Flatmap combine "Map Method" and "Flat Method".
        Only go 1 level deep, and CANNOT be changed
        Structure
            ARRAY.flatMap( (VALUE, INDEX, ARRAY) => OPERATION )
        Example
            const allMovements = accounts.map(acc => acc.movements).flat()
            const allMovements = accounts.flatMap(acc => acc.movements)
   
Sorting arrays
    Is a much-discussed topic in computer science and there are countless algorithms and methods of sorting values.
    For the moment we are going to use JS's built-in sort method
    Structure
        Array.sort(CURRENTVALUE , NEXTVALUE)
    This method MUTATE the original array
    Example:
        const owners = ['Jonas', 'Sarah', 'Adam', 'Martha'];
        console.log(owners.sort());                     // Resultado: ["Adam", "Jonas", "Martha", "Sarah"]
        console.log(owners);                            // Resultado: ["Adam", "Jonas", "Martha", "Sarah"]
    Strings
        A to Z
    Numbers
        NOT work. The method convert all to strings and try to sort it.
        It is possible fix it with a callback function.
        Logic:
            If function returns < 0 ===> a, b (Keep order)
            If function returns > 0 ===> b, a (Switch order)
            Ascending
            movements.sort((a, b) => a - b );
            Descending
            movements.sort((a, b) => b - a );
    Mixed strings and numbers
        NOT work at all

More ways of creating and filling arrays
    How to programmatically create and fill arrays
    Method 1: Empty + fill method
        Filling
            Structure
                Array.fill( VALUE, INITIAL, FINAL(notIncluded) )
            Mutate the original
        Example:
            const x = new Array(3);                 // Resultado: (3) [empty × 3] == [ , , ]
            x.fill(5)                               // Resultado: [5, 5, 5]
    Method 2: Array.form()  
        Structure
            Array.from({ length: NUMBER }, ( , VALUE) => OPERATION )
        Example
            Array.from({ length: 7 }, () => 1)                  // Resultado: [1, 1, 1, 1, 1, 1, 1]
            Array.from({ length: 7 }, ( _ , i) => i + 1)          // Resultado: [1, 2, 3, 4, 5, 6, 7]
    Method 3: QuerySelectorAll
        QuerySelectorAll returns a NodeList, wich is something like an array which contains all the selected elements. 
        So, it is necesary to convert it into an array

Which array method to use?
    To mutate original array
        Add to original
            .push       (end)
            .unshift    (start)
        Remove from original
            .pop        (end)
            .shift      (start)
            .splice     (any)
        Others
            .reverse
            .sort
            .fill
    A new array
        Computed from original
            .map        (loop)
        Filtered using condition
            .filter
        Portion of original
            .slice
        Adding original to other
            .concat
        Flattening the original 
            .flat
            .flatMap
    An array index
        Based on value
            .indexOf
        Based on test condition
            .findIndex
    Retrieve an array element
        Based on test condition
            .find
    Know if array includes a certain element
        Based on value
            .includes
        Based on test condition
            .some
            .every
    A new string
        Based on separator string
            .join
    To transform to value
        Based on accumulator
            .reduce         (Boil down array to single value of any type: number, string, boolean, or even new array or object)
    To loop over an array
        Based on callback
            .forEach        (Does not create a new array, just loops over it)


---------------------- NUMBERS, DATES, TIMERS AND BANKLIST ----------------------

Converting and checking numbers
    All numbers in JS are decimals.
        console.log(23 === 23.0);                           // Resultado: true
        Are represented internally based in a 64 base 2 format.
            Numbers are always stored in a binary format.
                Base 10 => 0 to 9
                Base 2 => 0 1
            In this system ys very complicated to represent fractions. For example: 0.1
                Base 10
                    Represent 1/10 is easy = 0.1
                    Represent 3/10 is imposible = 3.3333333333...
                Base 2
                    Represent 1/10 is imposible
        JS is very BAD for scientifics
            0.1 + 0.2 === 0.3                   // Resultado: false
    Convert string into number manually
        Number( "23" )
        + "23"
    Type coertion
        convert string into number automatically
        "23" === 23
    Parsing
        Number has methods to help us to analize. Is necessary than the string start with a number ("e23" not allowed)
            Number.parseInt("23px")
            Number.parseFloat("2.5rem")
        Parse accept other argument called "Regex". Is the base of the numeral system that we are using
            Number.parseInt("23px", 10 )
        In old JS it's been using parsing without "Number." but in modern JS is better to use it.
            Old JS:         parseFloat("2.5rem")
            Modern JS:      Number.parseFloat("2.5rem")
    isNaN
        Used to check if any value is a number. Boolean
            Number.isNaN('23')                          // Resultado: false
            Number.isNaN('23a')                         // Resultado: false
            Number.isNaN(+'23')                         // Resultado: true
            Number.isNaN(23 / 0)                        // Resultado: false
    Is Finite
        Used to check if any value is finite. Boolean
        Better method to know if a value is a number
            Number.isFinite(23)                         // Resultado: true
            Number.isFinite(23 / 0)                     // Resultado: false
            Number.isFinite("23")                       // Resultado: false
            Number.isFinite(+"23X")                     // Resultado: false
            Number.isFinite("23")                       // Resultado: true

Math and rounding
    Square Root
        Math.sqrt(25)                       // Resultado: 5
        25 ** (1 / 2)                       // Resultado: 5
        8 ** (1 / 3)                        // Resultado: 2
    Maximum and minimum
        Math.max(5,18,25,1,"150")           // Resultado: 150
        Math.min(5,18,25,1,"150")           // Resultado: 1
    Pi
        Math.PI
    Random
        Number between 0 and 1
        Math.random()
    Rounding
        Trunc eliminate the decimal part
        Round method round to the nearest integer
            Math.round(23.3)                // Resultado: 23
            Math.round(23.9)                // Resultado: 24
        Ceil method round up the integer
            Math.ceil(23.3)                 // Resultado: 24
            Math.ceil(23.9)                 // Resultado: 24
        Floor method round down the integer
            Math.floor(23.3)                // Resultado: 23
            Math.floor(23.9)                // Resultado: 23
        ALl of these works with type coertion
        Trunc and Floor works equal with positive number, but different with negative numbers
        Trunc and Ceil works equal with negative number, but different with positive numbers
    toFixed
        Used to adjust the number of decimals. Rounding the value
        Transforms the value into a String
            (2.227).toFixed(2)              // Resultado: 2.23 (string)
        We can transform again into a number
            +(2.227).toFixed(2)              // Resultado: 2.23 (float)
    As wee saw in the past, primitives has NOT methods but we use methods.
        It is possible because JS transform the primitives into boxes, aplly the method and later transform again into a primitive

The remainder operator
    Returns the remainder of a division into integers
        21 % 6                                  // Resultado: 3
        21 / 6                                  // Resultado: 3.5   ===> 21 = 6 * 3 + 3
    Even or odd number
        One number is even when is divisible by 2 and the remainder is 0
        21 % 2                                  // Resultado: 1     ====> Odd
        20 % 2                                  // Resultado: 0     ====> Even
    If we want to do something ever "NTH" time is a good idea to use the reminder operator
        Every third time
            if (i % 3 === 0){}
        Every fifth time
            if (i % 5 === 0){}
        Every eleventh time
            if (i % 11 === 0){}
        
Working with BigInt
    Introduced in ES2020
    Numbers are represented in 64 bits in JS = 64 ones or zeros
        From these 64 bits, 53 are used to store the digits themselves, the rest store the position of the decimal point and the sign
    Numbers bigget than (2^53 - 1) is not safe, what means it cannot be represented accurately
    A new primitive was added called BigInt.
    It can be used to store numbers as large as we want
    To transform into a big int it is necessary to add a "n" or with the method(not safe)
        1234254367866554323456765432134356              Normal Int. Not safe
        1234254367866554323456765432134356n             Bit Int. Safe
        BigInt(1234254367866554323456765432134356)      Bit Int. Not safe.
    Operations
        Works equal but only with BigInts
            1000n + 1000n                               // Resultado: 2000n
            1000n + 1000                                // Resultado: Error: cannot mix BigInt and other types
            10n / 3n                                    // Resultado: 3 ====> Returns the closest BigInt (remember the differente between 64 and 53 bits)
        The comparison still works mixing normal and big ints
            20n < 50            // Resultado: true
            20n == 20           // Resultado: true
            20n === 20          // Resultado: false ====> Not type coertion (different primitive type)
        The Math method for the moment is not working
            Math.sqrt(8n)       // Resultado: Error

Creating dates
    Form 1
        const date1 = new Date();               // Resultado: Sun Mar 07 2021 12:57:13 GMT+0100 (Central European Standard Time)
    Form 2
        new Date('Mar 12 2022 19:59:20')        // Resultado: Sat Mar 12 2022 19:59:20 GMT+0100 (Central European Standard Time)
    Form 3
        new Date(2037, 10, 19, 15, 23, 5));     // Resultado: Thu Nov 19 2037 15:23:05 GMT+0100 (Central European Standard Time)
        Year, month(Fanuary is month 0), day, hour, minute, second
    Form 4
        new Date(0)
        Unix time: 0 milliseconds after that initial Unix time
        new Date(3 * 24 * 60 * 60 * 1000)       // Resultado: Sun Jan 04 1970 01:00:00 GMT+0100 (Central European Standard Time)
    --> timestamp: (3 * 24 * 60 * 60 * 1000) = 259200000 this number is the "timestamp" of the day number three
    Timestamp
        We can obtain the date with the milliseconds passes since January 1, 1970
        new Date (2142253380000)                // Resultado: Thu Nov 19 2037 15:23:05 GMT+0100 (Central European Standard Time)
    Working with dates
        Example
            const future = new Date(2037, 10, 19, 15, 23);
        Get year
            future.getFullYear()                // Resultado: 2037
        Get month
            Start in month 0: January
            future.getMonth()                   // Resultado: 10 ==> Month number 11: November
        Get day
            future.getDate()                    // Resultado: 19
        Get day of the week
            Start in day 0: Sunday
            future.getDay()                     // Resultado: 4 ==> Day number 4: thursday
        Get hours, minutes and seconds
            future.getHours()                   // Resultado: 15
            future.getMinutes()                 // Resultado: 23
            future.getSeconds()                 // Resultado: 0
        Get the ISO string
            International Standard
            future.toISOString()                // Resultado: 2037-11-19T14:23:00.000Z
        Get timestamp
            future.getTime()                    // Resultado: 2142253380000
            Date.now()      // Obtain the timestamp until now
    Changing values
        Set Year
            future.setFullYear()                // Resultado: 2100
        Exists sets for all previous values

Operations with dates
    We convert to timestamp to realice operations
        +future                 // Resultado: 4130317380000
    Example
        const calcDaysPassed = (date1, date2) => Math.abs((date2 - date1) / (1000 * 60 * 60 * 24));
        calcDaysPassed(new Date(2037, 3, 14), new Date(2037, 3, 4));            // Resultado: 10

Internationalizing dates (IntL)
    JS has an API to transform dates depending the country
        day/month/year      ====>       month/day/year
    Creation
        new IntL.DateTimeFormat('LOCALS').format(DATE)
        new Intl.DateTimeFormat('en-US').format(new Date())             // Resultado: 07/03/2021
    Code locals table
        http://www.lingoes.net/en/translator/langcode.htm
    We can modify the INTL with differents propierties
        const options = {
            hour: 'numeric',
            minute: 'numeric',
            day: 'numeric',
            month: 'long',
            year: '2-digit',
            weekday: "long",
        };
        new Intl.DateTimeFormat('en-US', options).format(new Date())        // Resultado: Sunday, 7 March 21, 18:15
        new Intl.DateTimeFormat('es-ES', options).format(new Date())        // Resultado: domingo, 7 de marzo de 21, 18:15
    It is better adjust the internationalizing automatically
        const locale = navigator.language;                                  // Resultado: "en" or "es-ES" or whatever
        new Intl.DateTimeFormat(locale, options).format(new Date())

Internationalizing Numbers (IntL)
    Similar than dates
        new IntL.DateTimeFormat('LOCALS').format(NUMBER)
        new Intl.NumberFormat('es-ES').format(345654.45)                    // Resultado: 345.654,45
        new Intl.NumberFormat('us-GB').format(345654.45)                    // Resultado: 345,654.45
    It is posible change it with options
        const numberoptions = {
            style: 'unit',
            unit: 'mile-per-hour',
            // unit: "celsius",

            style: "percent"

            style: "currency"
            currency: "EUR",        Not affected by the local. It is necessary adjust manually
            useGrouping: false,     Without separator ( 3.500 = 3500)
        };
        new Intl.NumberFormat('es-ES', numberoptions).format(345654.45)                    // Resultado: 345.654,45 mi/h
        new Intl.NumberFormat('us-GB', numberoptions).format(345654.45)                    // Resultado: 345,654.45 mph

Timers: setTimeout and setInterval
    setTimeout
        Runs just once after a defined time
        We can use it to execute code at some point in the future
        Structure
            setTimeout(FUNCTION , MILLISECONDS, PARAMETERS);
            setTimeout( ()=>console.log('Here is your pizza') , 3000);
        The code no stops in the setTimeout, JS continue while setTimeout is background
        Example with parameters
            setTimeout( (ing1, ing2) => console.log('Here is your pizza'), 5000, 'olives', 'spinach');
        We can cancel the timer until the delay has actually passed
            if ( SOMETHING ) clearTimeout( TIMERNAME );
    setInterval
        Keeps running forever, until we stop it.
        Used when we want to do something every 10 seconds/minutes/hours
        Structure
            setInterval(FUNCTION , MILLISECONDS, PARAMETERS);
        Example
            setInterval(function () {
                const now = new Date();
                const hour = now.getHours();
                const minute = now.getMinutes();
                const second = now.getSeconds();
                console.log(`${hour}:${minute}:${second}`);
            }, 1000);
        We can cancel the timer
            if ( SOMETHING ) clearInterval( TIMERNAME );


---------------------- ADVANCED DOM AND EVENTS ----------------------

How the DOM really works
    Initial
        DOM: Document Object Model
        The DOM is the interface between all JS code and the browser, or more specifically HTML documents that are rendered in and by the browser
            JS  <---->  DOM (interface) <---->  Browser
    Definition
        DOM allows us to make JavaScript interact with the browser.
        We can write JavaScript to create/modify/delete HTML elements, set styles, classes and attributes, and listen/respond to events
        DOM tree is generated from an HTML document, which we can then interact with
        DOM is a very complex API(application program interface) that contains lots of methods and properties to interact with the DOM tree
            .querySelector()
            .addEventListener()
            .createElement()
            etc
    Organization
        Every single note in the DOM tree is of the type: node.
        Each node is represented in JS by an object. Which has access to different methods: textcontent, childnodes, etc
        Types of nodes
            Element
                <p></p>
                This type gives each HTML access to a ton of useful properties like: .innerHTML ; .classList ; etc
                This type has internally an HTML element, child type: HTMLElement
                    This HTMLElement itself has exactly one child type for each HTML element that exists in HTML
                        HTMLButtonElement ; HTMLDivElement ; etc
                        This differents child nodes has different methods: href ; etc
            Text
                Inside the Element ==> <p> Text </p>
                This is his own new node, separate from the Element node
            Comment
                <!-- -->
            Document
                .querySelector ; .createElement() ; etc
        Inheritance(herencia) of methods and properties
            Inheritance makes all work
            Inheritance means that all the child types will also get access to the methods and properties of all their parent node types
    Window Node
        Global object
        Lots of methods and properties
        Many unrelated to DOM
    EventTarget
        Way of the DOM of allowing all the node types to listen to events
            .addEventListener() ; .removeEventListener()
        Father of both the node type and also the window node type
    --> We DO NEVER CREATE an EventTarget object
    Scheme
        Event Target    ====> Window
                        ====> Node      ====> Element   ====> HTML Element  ====> HTMLButtonElement
                                        ====> Text                          ====> HTMLDivElement
                                        ====> Comment
                                        ====> Document
        theory-lectures-v2.pdf
            Slide 143

Selecting, creating and deleting elements ( TRABAJO )
    Selecting
        All the HTML
            document.documentElement
        Head
            document.head
        Body
            document.body
        Other elements
            document.querySelector()
            document.querySelectorAll()         ====> Generate a nodeList
        Get elements by ID
            document.getElementById()
        Get elements by tag name
            document.getElementsByTagName()     ====> Generate a live collection: updates automatically (if we delete something in the browser, the list actuallize)
        Get elements by class
            document.getElementsByClassName()
    Inserting
        .insertAdjacentHTML()
            document.querySelector('').insertAdjacentHTML(POSITIONtoATTACHinHTML, TEXT)
                Position to attach in HTML
                    'beforebegin': Before current element. Out of the element.
                    'afterend': After current element. Out of the element.
                    'afterbegin': Inside current element, after his first child element
                    'beforeend': Inside current element, before his last child element
            document.querySelector('.main').insertAdjacentHTML(afterbegin, "Prueba")
        .prepend()
            .prepend(document.createElement('div').innerHTML = 'We use cookies for improved functionality and analytics.';)
            Adds the element as the first child of this element
        .append()
            .append(document.createElement('div').innerHTML = 'We use cookies for improved functionality and analytics.';)
            Adds the element as the last child of this element
        If we want to insert the same element prepend and append
            .append( document.createElement('div').innerHTML = 'We use cookies for improved functionality and analytics.'.cloneNode(true) )
        .before()
            Same as prepend
        .after()
            Same as append
    Creating
        .createElement( ELEMENT )
            .createElement('div')
    Deleting
        .remove()
            document.querySelector(".boton").remove()
            Method very recent
        Before remove() we use
            document.querySelector(".boton").parentElement.removeChild(document.querySelector(".boton"))
            First select the parent node and later remove the child

Styles, attributes and classes
    Styles
        document.querySelector(".boton").style.PROPIERTY
        document.querySelector(".boton").style.backgroundColor = "blue
            This styles are writing in the HTML, not in the css archive.
                <button class="boton" style="background-color: rgb(55, 56, 61); width: 120%;" ></button>
                This is called Inline Styles
        It is not possible to read the propierties if they are in the css archive.
            console.log( document.querySelector(".boton").style.height );               // Resultado: ""
            Only we can read the styles if they are inline styles
    --> getComputedStyle
            It is possible to know the propierties in the css archive of the element using this method
            console.log( getComputedStyle(document.querySelector(".boton")).height );         // Resultado: 50px
        Other form to change properties styles
            document.documentElement.style.setProperty( PROPIERTYnAME, VALUE);
            document.documentElement.style.setProperty('--color-primary', 'orangered');
            document.body.style.setProperty('background-color', 'blue');
            It is better to use style.PROPIERTY
    Attributes
        src ; alt ; id ; class ; ...
        Select the attribute
            document.querySelector().src
            document.querySelector().alt
            document.querySelector().className
            If we create a non standar attribute, JS can't read it
                document.querySelector().nuevo
            But, exists one method to read this non-standard attribute
                document.querySelector().getAttribute('nuevo')
        Setting the value of the attribute
            document.querySelector().alt = '';
            document.querySelector().alt = 'Beautiful minimalist logo';
            document.querySelector().setAttribute(PROPIERTY, VALUE)
            document.querySelector().setAttribute('company', 'Bankist')
        Data attributes
            HTML    ==>     data-version-number="3.0"
            JS      ==>     qs.dataset.versionNumber        // Resultado: 3.0
    Classes
        qs.classList.add(' ' , ' ');
            --> qs.className = 'jonas'; ==!==> DON'T USE, OVERRIDE ALL THE EXISTING CLASSES
        qs.classList.remove(' ' , ' ');
        qs.classList.toggle(' ' , ' ');
        qs.classList.contains(' ' , ' ');

Implementing smooth scrolling
    Old School
        Know the coordinates
            .getBoundingClientRect()
            console.log(qs.getBoundingClientRect())         // Resultado: bottom: 1542, height: 1530, left: 0, right: 1024, top: 12, width: 1024, x: 0, y: 12
            The coordinates are relative to the visible view port. If we scroll the page, the coordinates will change
                Current scroll (x/y): window.pageXOffset, pageYOffset
                Height/width viewport: document.documentElement.clientHeight, document.documentElement.clientWidth
        Scrolling
            window.scrollTo(LEFTPOSITION , TOPPOSITION);                            // Relative to the viewport, NOT to the document
            window.scrollTo(s1coords.left, s1coords.top);
            To fixed the relative position we can add the current position
            window.scrollTo(LEFTPOSITION + window.pageXOffset, TOPPOSITION + window.pageYOffset);        // Absolute position
            window.scrollTo(s1coords.left, s1coords.top + window.pageYOffset);
        Smooth Scrolling
            We use the same scrollTo but we pass one object
            qs.addEventListener('click', function () {
                window.scrollTo({
                        left: qs.getBoundingClientRect().left + window.pageXOffset,
                        top: qs.getBoundingClientRect().top + window.pageYOffset,
                        behavior: 'smooth',
                })}
    Modern School. Only work in modern browsers
        Similar than old school but faster and without coordinates
            qs.addEventListener('click', function () {
                qs.scrollIntoView({ 
                    behavior: 'smooth' 
                })
            }

Types of events and event handlers
    Event: signal that is generated by a certain DOM node.
        addEventListener(TYPEEVENT, FUNCTION)       ----> Modern JS
            qs.addEventListener('click', function(){ console.log('clicking') } )
            Permit multiple events: qs.addEventListener("click", cl("1"));  qs.addEventListener("click", cl("2"));          // Resultado: 1, 2
            We can remove an event handler
        onTYPEEVENT = FUNCTION                      ----> OLD JS
            qs.onclick = function(){ console.log('clicking') };
            Override the events: qs.onlick = cl("1");  qs.onlick = cl("2");                                                 // Resultado: 2
            Can NOT remove an event handler
        Click mouse, mouse moving, triggering the full screen mode, etc
    Events
        https://developer.mozilla.org/en-US/docs/Web/Events
        https://developer.mozilla.org/en-US/docs/Web/API/Element
        The most importants are the "Mouse events" and the "Keyboards events"
        Type event: mouseenter  
            Work like "hover" in CSS
        Type event: mouseleave
            The opposite of mousenter
    Remove event listener
        Necesary the function was outside.
            const alertH1 = function () { console.log('Mouse OUT')};
        .removeEventListener inside the function
            const alertH1 = function(){cl, qs.removeEventListener(TYPEeventListener, alertH1)}
        It is possible remove after a while
            setTimeout(()=> qs.removeEventListener(TYPEeventListener, alertH1), milliseconds)
    Using HTML attribute
        This actually should NOT be used
        Define directly on HTML
            <h1 onclick="console.log('Mouse OUT') >Titulo</h1>

Event propagation: bubling and capturing ( Page 146 )
    Capturing phase
        The event is in the document, and travel allong the nodes until the target
            Document --> Element(html) --> El(body) --> El(section) --> El(p) --> El(a)
    Target phase
        Then the event reaches the target, the target phase begins.
        Event listeners wait for a certain event to happen on a certain element and as soon as the event occurs, it runs
            document.querySelector("a").addEventListener("click",function)        
    Bubling phase
        Then the event travel all the way up to the document route again
            Document <-- Element(html) <-- El(body) <-- El(section) <-- El(p) <-- El(a)
        So, we say that events bubble up from the target to the document route
    So as an event travels down and up the tree, they pass through all the parent elements but not through any sibling element
    This is very important bassically the event happen in all of the parent elements.
        If we attach the same event listener also to the parent element, then we would get the exact result
        document.querySelector("a").addEventListener("click",function)
        document.querySelector("p").addEventListener("click",function)
        document.querySelector("section").addEventListener("click",function)
    Now by default, events can only be handle in the targer and in the bubbling phase
    However, we can set up event listeners in a way that they listen to events in the capturing phase instead
    We can say that "events propagate from one place to another"
    Also not happen on ALL events
    So, if one element has one event listener and his parent has other event listening with the same type of event(click, mouseenter). Both will ocurr
        qs("button").addEventListener("click",function(){console.log("Child Node")})
        qs("section").addEventListener("click",function(){console.log("Parent Node")})
        <section>
            <button>Boton</button>
        </section>
        When we click on "Boton", the console show: Child Node, Parent Node
    Event target
        That triggers an event
        addEventListener("click", function(e){ console.log( e.target )})
    Current target
        Element on which the event is attached
        addEventListener("click", function(e){ console.log( e.currentTarget )})
        e.currentTarget === this
    Stop the event propagation
        We can stop the bubbling
        e.stopPropagation() in the function
        qs("button").addEventListener("click",function(){console.log("Child Node");e.stopPropagation()})
        qs("section").addEventListener("click",function(){console.log("Parent Node")})
        When we click on "Boton", the console show: Child Node
        NOT A GOOD IDEA TO STOP THE PROPAGATION
    Capturing phase propagation
        addEventListener only ocurr in bubling phase but, we can change it
            addEventListener("click", function, false)          // Capturing in bubling phase(default)
            addEventListener("click", function, true)           // Capturing in capture phase
        The result is the same but the path is the other way around

Event delegation: implementing page navigation
    We put the event listener on a common parent of all the elements that we are interested
    Not possible to attach listeners to element that not exists in the HTML, but we can create a listener to the parent and create dynamically the element who trigger it
    Steps
        1. We add the event listener to a common parent element of all the elements that we're interested in
        2. Determine what element originated the event ====> e.target
    Matching strategy
        It is goot to check if the target element contains the class that we are interested in
        Because, if we click in the element parent, and not in the chil that we are interested, the event trigger
    Example
        document.querySelector(PARENT).addEventListener('click', function (e) {
            e.preventDefault();
            // Matching strategy
            if (e.target.classList.contains(CHILD)) {
                document
                    .querySelector(e.target.getAttribute('href'))
                    .scrollIntoView({ behavior: 'smooth' });
            }
        });

DOM traversing
    Is walking through the DOM. Which means that we can select an element based on another element.
    Is very important because sometimes we need to select elements relative to a certain other element
        A direct child or a direct parent element
        Sometimes we don't even know the structure of the DOM at runtime
    Going downwards: selecting the Childs
        document.querySelector(PARENT).querySelector(CHILD)
        document.querySelector(PARENT).querySelectorAll(CHILD)
        No matter how deep these child elements would be inside the parent element
        document.querySelector(".padre1").querySelectorAll(".hijo")
        If exist more ".hijo" in the document, they will not be selected because they are not childs of ".padre1"
        Know the child elements
            qs.childNodes       Give all the child nodes(whether or not they have class). Not very used
            qs.children         Give all only the elements. Only for direct childs
        First and last element child
            qs.firstElementChild
            qs.lastElementChild
    Going upwards: selecting parents
        Direct parent
            qs.parentNode
            qs.parentElement
    --> Not direct parent
            qs.closest("PARENT")
            Very used in event delegation
            Is the "opposite" of querySelector
    Going sideways: selecting siblings
        We can only access direct siblings, basically only the previous and the next one
        Elements
            qs.previousElementSibling
            qs.nextElementSibling
        Nodes: Not very used, better option working with elements
            qs.previousSibling
            qs.nextSibling
        For all the sibling
            qs.parentElement.children

Passing arguments to event handlers
    Structure of the listener for 1 parameter
        qs.addEventListener('click', FUNCTION.bind( PARAMETER ));
    Structure of the function for 1 parameter
        const logueando = function (e) {
            console.log( this );
        };
    Structure of the listener for more than 1 parameter
        qs.addEventListener('click', function(){ FUNCTION( PARAMETERS ) });
    Structure of the function for more than 1 parameter
        const logueando = function (parameter1, parameter2) {
            console.log( parameter1 , parameter2 );
        };

Implementing a sticky navigation: the scroll event (NOT USE)
    NOT use this scroll event because fire all the time, no matter how small the change is here in the scroll.
        Bad performance, specifically in mobile
    When window is larger than initial coords section (depends of the windows itself), add the class "sticky" in CSS.
        const initialCoords = qs(".section1").getBoundingClientRect();
        window.addEventListener('scroll', function () {
            if (window.scrollY > initialCoords.top) {
                nav.classList.add('sticky');
            } else {
                nav.classList.remove('sticky');
            }
        });

Implementing a sticky navigation: intersection observer API
    Much better method than previous
    This API allows our code to observe changes to the way that a certain target element intersects another element or the way it intersects the viewport
    Creation
        const observer = new IntersectionObserver(observerCallBack, observerOptions);
    observerCallBack
        This function will get called each time that the observer element, or our target element.
        It's intersecting the root element at the threshold that we defined.
        No matter if we are scrolling down or up.
            const observerCallBack = function (entries, observer) {
                console.log("HEY");
            };
    observerOptions
        Object formed by two propierties
        const observerOptions = {
            root: null,                     // Is the element that the target is intersecting. null == viewport
            rootMargin: "+/-90px"           // Margin around the root.
            rootMargin: "-90px"             // The function fires 90px before the threshold was actually reached
            threshold: 0.1,                 // Is the percentage of intersection at which the observer callback will be called(0.1===10%)
            threshold: [0.1, 0.5, 0.8],     // Can be exist multiple threshold
            threshold: [0, 1],              // 0: Before it is seen // 1: After it is seen
        };
    Calling the observer
        observer.observe(TARGETELEMENT);
        observer.observe(section1);

Revealing elements on scroll
    The animation actually comes from CSS
    We will achieve this by simply adding a class to each of the sections
        .section--hidden {
            opacity: 0;
            transform: translateY(8rem);
        }
        It is better to add and remove the class with JS because a lot of people disable JS and this people don't see the web
    It works using the intersection observer API
        const revealSection = function (entries, observer) {
            const [entry] = entries;
            if (!entry.isIntersecting) return;
            entry.target.classList.remove('section--hidden');
            // When the observer do it work, disable the observer
            observer.unobserve(entry.target);
        };
        const sectionObserver = new IntersectionObserver(revealSection, {
            root: null,
            threshold: 0.15,
        });
        We add the hidden class and put the observer for each section
        qs.forEach(function (section) {
            sectionObserver.observe(section);
            section.classList.add('section--hidden');
        });

Lazy loading images
    Very important to optimice the images in the web ==> Lazy Loading Images
    For low resolution images we use in the HTML (1KB)
        src=".../image.jpg"
    For the same image but with more resolution in the HTML (10MB)
        data-src=".../imageHD.jpg"
    Those names are not standards but it is good to use it for simplicity
    Filter in CSS for low resolution images
        .lazy-img {
            filter: blur(20px);
        }
    It is very important to use this for better perfomance for users with low internet
    We use the intersection observer API
        We only select the img with the property "data-src" which have the blur effect
        const imgTargets = document.querySelectorAll('img[data-src]'); 
        const loadImg = function (entries, observer) {
            const [entry] = entries;
            if (!entry.isIntersecting) return;
            // Replace the src with data-src
            entry.target.src = entry.target.dataset.src;
            // Remove the blur filter. We remove the class blur after load the new image with the event listener. Pretty effect
            entry.target.addEventListener('load', function () {
                entry.target.classList.remove('lazy-img');
            });
            observer.unobserve(entry.target);
        };
        const imgObserver = new IntersectionObserver(loadImg, {
            root: null,
            threshold: 0,
            rootMargin: '200px',           // To start loading before the user arrives
        });
        // Add the observer for each image
        imgTargets.forEach(img => imgObserver.observe(img));

Lifecycle DOM events
    Lifecycle: the page is first accessed until the yser leaves it
    DOM content loaded event
        Fired by the document as soon as the HTML is completely parsed(HTML has been downloaded and been converted to the DOM tree)
        Not wait for images and other external resources to load. Just HTML and JS need to be loaded.
        Al scripts must be downloaded and executed before the DOM content loaded event can happen
            document.addEventListener("DOMContentLoaded", function (e) {})
        Important to load the JS after the page loaded at 100% when we call the JS at the beginning in the HTML
            <script src="script.js"></script>       Line 15: we put all the JS code inside that listener and when the page was parsed, JS will run
            <script src="script.js"></script>       Line 400: Not necesary this listener. At the end of all.
        This event in modern JS (DOM content loaded event) is the equivalent of "document.ready" in JQuery
    Load Event
        Fired when all the page was downloaded: CSS, images, external resources, ect
            window.addEventListener('load', function (e) {})
    Before unload event
        Created immediately before a user is about to leave a page. For example: after clicking the close button in the browser
            window.addEventListener('beforeunload', function (e) {}
        We can use this event to ask users if they are 100% sure that they want to leave the page
            e.preventDefault();
            console.log(e);
            e.returnValue = ''; Not possible to personalice the message, because a lot of people abuse of this

Efficient script loading: defer and sync (Page 149)
    We can write the script tag in the head of the HTML or in the body end
        <head>
            <script src="script.js">
        </head>
        <body>
            ...
            <script src="script.js">
        </body>
    Regular
        Example
            <script src="script.js">
        Head
            1. Start parsing HTML
            2. Stop parsing HTML: Read and execute the scripts JS
            3. Finish parsing HTML
            4. DOMContentLoaded
            ---- Parsing HTML ----> Wating (read and execute JS) ----> Finish parsing HTML
            This is not very efficient because the parse stop and this impact on the pages performance.
            NEVER include the script JS in the head
        Body End
            1. Parsing all the HTML
            2. Without waiting: Read and execute the scripts JS
            3. DOMContentLoaded
            ---- Parsing HTML ----> Read and execute JS
            The parse HTML no stop and this is better for pages performance.
            ALWAYS include the script JS in the body end
            But this is is no perfect for asynchronous
        --> Used when
                Use if you need to support old browsers
    Async
        Example
            <script async src="script.js">
        Head
            1. Parsing HTML and read the scripts JS
            2. Stop parsing HTML: Execute the scripts JS
            3. Finish parsing HTML
            4. DOMContentLoaded
            ---- Parsing HTML and read JS ----> Wating (execute JS) ----> Finish parsing HTML
            The parsing HTML and the reading of the scripts JS working at the same time but still stopping for executing the JS
            Beter performance than regular
            Usually the DOMContentLoaded event waits for all scripts to execute, except for async scripts. So, DOMContentLoaded fires after async scripts execute
                Parsing HTML------------
                Execute normal JS-------
                                        DOMContentLoaded
                Execute async JS------------------                        
            Scripts not guaranteed to execute in order
        --> Used when
                Use for 3rd-party scripts where order doesn’t matter (e.g. Google Analytics)
        Body End
            Don't make sense because the read and the execution happen at the end and "async" makes no sense here
    Defer (aplazar)
        Example
            <script defer src="script.js">
        Head
            1. Parsing all the HTML and read the scripts JS
            2. Without waiting: Execute the scripts JS
            4. DOMContentLoaded
            ---- Parsing HTML and read JS ----> Execute JS
            The parsing HTML and the reading of the scripts JS working at the same time and JS execute upon finished the parsing HTML
            Similar performance than async but the parsing is never interrupted and many times we wan't this.
            DOMContentLoaded event fires after defer script is executed
                Parsing HTML------------
                Execute normal JS-------
                                                DOMContentLoaded
                Execute async JS----------------
            Scripts are executed in order
        --> Used when
                This is overall the best solution! Use for your own scripts, and when order matters (e.g. including a library)
        Body End
            Don't make sense because the read and the execution happen at the end and "defer" makes no sense here
    You can, of course, use different strategies for different scripts.
        Usually a complete web applications includes more than just one script.
        In all browsers ignore the async and defer
            


